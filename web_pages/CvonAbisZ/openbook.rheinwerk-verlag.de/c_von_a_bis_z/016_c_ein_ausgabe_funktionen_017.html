<html>

<!-- Mirrored from openbook.rheinwerk-verlag.de/c_von_a_bis_z/016_c_ein_ausgabe_funktionen_017.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 23 Jun 2017 19:47:47 GMT -->
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Rheinwerk Computing :: C von A bis Z &ndash; 16.17 Blockweise lesen und schreiben &#8211; »fread()« und »fwrite()«</title>
<meta name="title" content="Rheinwerk Computing :: C von A bis Z - 16.17 Blockweise lesen und schreiben &#8211; »fread()« und »fwrite()«">
<meta name="author" content="J&uuml;rgen Wolf ">
<meta name="publisher" content="Rheinwerk Verlag GmbH 2009">
<meta name="copyright" content="Rheinwerk Verlag GmbH 2009">
<meta name="Description" content="C von A bis Z - Das umfassende Handbuch &ndash; 16.17 Blockweise lesen und schreiben &#8211; »fread()« und »fwrite()«">
<meta name="audience" content="Alle">
<meta name="robots" content="INDEX,FOLLOW">
<meta http-equiv="content-language" content="de">
<link rel="stylesheet" type="text/css" href="common/rw_open.css">
<link rel="prev" href="016_c_ein_ausgabe_funktionen_016.html">
<link rel="next" href="016_c_ein_ausgabe_funktionen_018.html"><script type="text/javascript"><!--
    function OpenWin(url,name,height,width)
    {
      var InfoWin = window.open(url,name,"directories=0,height="+height+",width=" + width + ",hotkeys=0,location=0,menubar=0,resizable=1,screenX=150,screenY=10,left=150,top=10,scrollbars=1,status=1,titlebar=0,toolbar=0");
      InfoWin.focus();
    }
    //--></script><link href="common/prettify.css" type="text/css" rel="stylesheet"><script type="text/javascript" src="common/prettify.js"></script></head>
<body vlink="#000099" link="#000099" alink="#000099" onload="prettyPrint()">
<table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#00549d">
<tr>
<td height="74" valign="bottom" colspan="2"><a href="https://www.rheinwerk-verlag.de/katalog/openbook?GPP=opc3"><img src="common/rw_openbook.gif" width="200" height="56" border="0" alt="Rheinwerk Computing < openbook >" title="Rheinwerk Computing < openbook >"></a></td>
<td width="80" height="74"><a href="https://www.rheinwerk-verlag.de/?GPP=opc3"><img src="common/rw_computing.gif" border="0" alt="Rheinwerk Computing - Professionelle Bücher. Auch für Einsteiger." title="Rheinwerk Computing - Professionelle Bücher. Auch für Einsteiger."></a></td>
</tr>
</table>
<div align="right"><a href="https://www.rheinwerk-verlag.de/?GPP=opc3" class="navnav">Professionelle Bücher. Auch für Einsteiger.</a></div><br><table class="tbl" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="190" valign="top">
<table class="tbl1" border="0" cellpadding="3" cellspacing="0" width="190" align="left">
<tr>
<td class="tbl2"><a class="nav" href="index-2.html#_top">Inhaltsverzeichnis</a></td>
</tr>
<tr>
<td><a class="navnav" href="000_c_vorwort_001.html#mj764cb3fd439d3b95d1843e7c7d17f235">Vorwort</a></td>
</tr>
<tr>
<td><a class="navnav" href="000_c_vorwort_gutachter_001.html#mj3d41cb339c9b2fc1d6e99cdaa93c3860">Vorwort des Gutachters</a></td>
</tr>
<tr>
<td><a class="navnav" href="001_c_einstieg_in_c_001.html#mja24d93ff97bb42dbebf4689160c45195">1 Einstieg in C</a></td>
</tr>
<tr>
<td><a class="navnav" href="002_c_das_erste_programm_001.html#mj2604a667cc98d3fa2178751273346b91">2 Das erste Programm</a></td>
</tr>
<tr>
<td><a class="navnav" href="003_c_grundlagen_001.html#mj7ac54ba315b94149806c1de3fc89ee7f">3 Grundlagen</a></td>
</tr>
<tr>
<td><a class="navnav" href="004_c_ein_ausgabe_001.html#mj20c131820fbfb1497afd796ee443599e">4 Formatierte Ein-/Ausgabe mit »scanf()« und »printf()«</a></td>
</tr>
<tr>
<td><a class="navnav" href="005_c_basisdatentypen_001.html#mjeda2957449ddc812dad62b400fe57752">5 Basisdatentypen</a></td>
</tr>
<tr>
<td><a class="navnav" href="006_c_operatoren_001.html#mjab3693b096d581607801a36ce88905fc">6 Operatoren</a></td>
</tr>
<tr>
<td><a class="navnav" href="007_c_typumwandlung_001.html#mj5c5e497ac2ab4367fe9df0ffd218cfca">7 Typumwandlung</a></td>
</tr>
<tr>
<td><a class="navnav" href="008_c_kontrollstrukturen_001.html#mjc7bf6f584a2fe20b4c5f6b16ba15d57d">8 Kontrollstrukturen</a></td>
</tr>
<tr>
<td><a class="navnav" href="009_c_funktionen_001.html#mj7893101be51aa469fe52334038acd465">9 Funktionen</a></td>
</tr>
<tr>
<td><a class="navnav" href="010_c_praeprozessor_001.html#mjacdd200a20163a4d3fa418b6cb95763e">10 Präprozessor-Direktiven</a></td>
</tr>
<tr>
<td><a class="navnav" href="011_c_arrays_001.html#mje29de26c54a3884f7316cbbb2a073ad8">11 Arrays</a></td>
</tr>
<tr>
<td><a class="navnav" href="012_c_zeiger_001.html#mjee28a882ef9125d2c4cc49121b2c65c1">12 Zeiger (Pointer)</a></td>
</tr>
<tr>
<td><a class="navnav" href="013_c_kommandozeilenargumente_001.html#mjf6a9e42fa3bc25b2b1e06270e7bf8f68">13 Kommandozeilenargumente</a></td>
</tr>
<tr>
<td><a class="navnav" href="014_c_dyn_speicherverwaltung_001.html#mj8d062301d2449b13710f1484d499cd9b">14 Dynamische Speicherverwaltung</a></td>
</tr>
<tr>
<td><a class="navnav" href="015_c_strukturen_001.html#mj5e146ba18168113a5c645cd2d07c4ec8">15 Strukturen</a></td>
</tr>
<tr>
<td><a class="navh" href="##mj136f9ac6b5b7c440aafe5010411ef011">16 Ein-/Ausgabe-Funktionen</a></td>
</tr>
<tr>
<td><a class="navnav" href="017_c_dateien_verzeichnisse_001.html#mj9f81aea722a9edb8d0080df81eb9402c">17 Attribute von Dateien und das Arbeiten mit Verzeichnissen (nicht ANSI C)</a></td>
</tr>
<tr>
<td><a class="navnav" href="018_c_stdarg_h_001.html#mj9d64febdc46a1375e5c4498b17154e30">18 Arbeiten mit variabel langen Argumentlisten &#8211; &lt;stdarg.h&gt;</a></td>
</tr>
<tr>
<td><a class="navnav" href="019_c_zeitroutinen_001.html#mj0a8102e96a1297bd767ac7274e069f0f">19 Zeitroutinen</a></td>
</tr>
<tr>
<td><a class="navnav" href="020_c_headerdateien_001.html#mjf3caede8ebd504dc6b7454b297c251e8">20 Weitere Headerdateien und ihre Funktionen (ANSI C)</a></td>
</tr>
<tr>
<td><a class="navnav" href="021_c_dyn_datenstrukturen_001.html#mja75ba2f4ab8f95e9e321d195c1e26d76">21 Dynamische Datenstrukturen</a></td>
</tr>
<tr>
<td><a class="navnav" href="022_c_algorithmen_001.html#mj07afe6f332eab2e8168da2f69f7b31c4">22 Algorithmen</a></td>
</tr>
<tr>
<td><a class="navnav" href="023_c_cgi_001.html#mj6c4219b4e615fa24deaa57d5c3d04db8">23 CGI mit C</a></td>
</tr>
<tr>
<td><a class="navnav" href="024_c_mysql_001.html#mj12dab301033f9fd856aa739270c45e08">24 MySQL und C</a></td>
</tr>
<tr>
<td><a class="navnav" href="025_c_netzwerkprogrammierung_001.html#mja8101c6e0e4cb2e6fd8312114dad30d7">25 Netzwerkprogrammierung und Cross&ndash;Plattform-Entwicklung</a></td>
</tr>
<tr>
<td><a class="navnav" href="026_c_paralleles_rechnen_001.html#mj710dc0ad851d57e60533f8797ff9c1e6">26 Paralleles Rechnen</a></td>
</tr>
<tr>
<td><a class="navnav" href="027_c_sicheres_programmieren_001.html#mj13eba8f9d68ac8414bffaa3a1b24ec31">27 Sicheres Programmieren</a></td>
</tr>
<tr>
<td><a class="navnav" href="028_c_weiterfuehrendes_001.html#mj3e65f750149ade087925f303b3871af9">28 Wie geht&#8217;s jetzt weiter?</a></td>
</tr>
<tr>
<td><a class="navnav" href="029_c_anhang_a_001.html#mjec9bf1c5e3fe2e46047c2f9c7aa9c531">A Operatoren</a></td>
</tr>
<tr>
<td><a class="navnav" href="030_c_anhang_b_001.html#mj803443bb6e7546011c48e6e57fbdbb64">B Die C-Standard-Bibliothek</a></td>
</tr>
<tr>
<td><a class="navnav" href="stichwort.html#_top">Stichwort</a></td>
</tr>
<!--<tr>
<td><br><a href="http://download.galileo-press.de/openbook/c_von_a_bis_z/galileocomputing_c_von_a_bis_z.zip" class="navnav"><strong>Download:</strong><br>- ZIP, ca. 10,3 MB</a></td>
</tr>-->
<tr>
<td><br><a href="https://www.rheinwerk-verlag.de/2132/?GPP=opc3" class="navnav">Buch bestellen</a></td>
</tr>
<tr>
<td><a class="navnav" href="#kommentar">Ihre Meinung?</a><br><br></td>
</tr>
</table>
</td>
<td width="10"><img src="common/spacer10.gif" width="10" height="10" alt="Spacer"></td>
<td width="85%" valign="top" align="center"><div align="center">
<table width="98%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a href="016_c_ein_ausgabe_funktionen_016.html" class="navnav"> &lt;&lt;   zurück</a></td>
<td width="49%"><div align="center"><a href="https://www.rheinwerk-verlag.de/?GPP=opc3" class="navnav">Rheinwerk Computing</a> / <a href="https://www.rheinwerk-verlag.de/openbook/?GPP=opc3" class="navnav">&lt;openbook&gt;</a> / <a href="index-2.html" class="navnav"> C von A bis Z</a></div></td>
<td align="right" width="25%"><div align="right"><a href="016_c_ein_ausgabe_funktionen_018.html" class="navnav">vor   &gt;&gt; </a></div></td>
</tr>
</table></td>
</tr>
<tr>
<td width="100%" valign="top"><table width="100%" border="0" cellpadding="10" cellspacing="0" class="box">
<tr>
<td colspan="2"><a href="https://www.rheinwerk-verlag.de/2132/?GPP=opc3" class="buchtitel">C von A bis Z</a><span class="autor"> von J&uuml;rgen Wolf </span><br><span class="untertitel">Das umfassende Handbuch</span></td>
</tr>
<tr>
<td valign="top" width="211"><dl>
<dt><a href="https://www.rheinwerk-verlag.de/2132/?GPP=opc3" class="navnav"><img src="common/9783836214117.gif" border="0" alt="Buch: C von A bis Z" title="Buch: C von A bis Z"></a></dt>
<dd><br><a href="https://www.rheinwerk-verlag.de/2132/?GPP=opc3"><span class="autor"><strong>C von A bis Z</strong><br>3., aktualisierte und erweiterte Auflage, geb., mit CD und Referenzkarte<br>1.190 S., 39,90 Euro<br>Rheinwerk Computing<br>ISBN 978-3-8362-1411-7</span></a></dd>
</dl></td>
<td width="80%"><table border="0">
<tr>
<td valign="baseline"><img src="common/pfeil_u.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="3" class="kap"><strong><a href="016_c_ein_ausgabe_funktionen_001.html#mj136f9ac6b5b7c440aafe5010411ef011" class="navnav">16 Ein-/Ausgabe-Funktionen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_001.html#mj4c867f68333349b78c5d61ab2e017aae" class="navnav">16.1 Was ist eine Datei?</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_002.html#mj7e0dfaa010e3c9ec2a3b039e54bce268" class="navnav">16.2 Formatierte und unformatierte Ein-/Ausgabe</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_003.html#mjc93191818792ac003a79b031035d4018" class="navnav">16.3 Standard-Streams</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_004.html#mj933d3cc5869070380c6a8d68958eed05" class="navnav">16.4 Höhere Ein-/Ausgabe-Funktionen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_005.html#mj47f082541eb4df9dbdcefdbc2775feae" class="navnav">16.5 Datei (Stream) öffnen &#8211; »fopen«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_005.html#mj2f57f419fdeadcd1c7dd4e001616d21a" class="navnav">16.5.1 Modus für »fopen()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_005.html#mjd78eb35b8f5e3230fb62a9823cb1801e" class="navnav">16.5.2 Maximale Anzahl geöffneter Dateien &#8211; »FOPEN_MAX«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_006.html#mja821f1d0ab158bed792eccc5f30e3f84" class="navnav">16.6 Zeichenweise lesen und schreiben &#8211; »getchar()« und »putchar()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_006.html#mj4097573a931a82cba06a1c2ce037325d" class="navnav">16.6.1 Ein etwas portableres »getch()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_007.html#mjc9c7a50e6c2ac045cd5fdedafb67251f" class="navnav">16.7 Zeichenweise lesen und schreiben &#8211; »putc()«/»fputc()« und »getc()«/»fgetc()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_008.html#mj13977630d07d7d1f3615135a518a478b" class="navnav">16.8 Datei (Stream) schließen &#8211; »fclose()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_009.html#mje5a9730700783816c72f0f4556b59d10" class="navnav">16.9 Formatiertes Einlesen/Ausgeben von Streams mit »fprintf()« und »fscanf()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_010.html#mja405f2e8d16be96b75ee88fcbe398615" class="navnav">16.10 Standard-Streams in C</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_010.html#mj9dbf91fb0f12de81b779d8be658b7b63" class="navnav">16.10.1 Standard-Streams umleiten</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_011.html#mjb930733ba3e062cb3df828cab6ac39b4" class="navnav">16.11 Fehlerbehandlung von Streams &#8211; »feof()«, »ferror()« und »clearerr()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_012.html#mj7d29d53b9da9d217f2f5187ea1184e86" class="navnav">16.12 Gelesenes Zeichen in die Eingabe zurückschieben &#8211; »ungetc()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_013.html#mj916b50e93a84be77b338cb8023b6fafc" class="navnav">16.13 (Tastatur-)Puffer leeren &#8211; »fflush()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_014.html#mjff798e62f1469fc3901b349f005d6547" class="navnav">16.14 Stream positionieren &#8211; »fseek()«, »rewind()« und »ftell()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_015.html#mjeedfe60fb34e4608925d9785db986435" class="navnav">16.15 Stream positionieren &#8211; »fsetpos()«, »fgetpos()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_016.html#mjb5f0f6be89b2708a1d3388f2266093e5" class="navnav">16.16 Zeilenweise Ein-/Ausgabe von Streams</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_016.html#mjceae94d455526a1bb0846ed53314fef2" class="navnav">16.16.1 Zeilenweise lesen mit »gets()«/»fgets()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_016.html#mj89d09323b58ff56fd8b314a2fe803d57" class="navnav">16.16.2 Zeilenweise schreiben mit »puts()«/»fputs()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_016.html#mj37828f5c575bb30773c771db5616949b" class="navnav">16.16.3 Zeilenweise vom Stream einlesen mit »getline()«
(nicht ANSI C)</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_016.html#mjcea47bd6d32a4a8f51be329a672845d7" class="navnav">16.16.4 Rezepte für zeilenweises Einlesen und Ausgeben</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="#mjd6205d099779f805fd974466f81d3e86" class="navh">16.17 Blockweise lesen und schreiben &#8211; »fread()« und »fwrite()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj650d52c45fd8c662ee1fc078a23487ef" class="navh">16.17.1 Blockweise lesen &#8211; »fread()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj72d8bcd5c9fd159c248b24caf558e345" class="navh">16.17.2 Blockweise schreiben &#8211; »fwrite()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjdcd1441c7ba913a6400250870e2e06cd" class="navh">16.17.3 Big Endian und Little Endian</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_018.html#mjdea3be88c491b66e0c30cb6efbdf5b16" class="navnav">16.18 Datei (Stream) erneut öffnen &#8211; »freopen()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_019.html#mj90ce4661683446b0c5f4d0f8704358d3" class="navnav">16.19 Datei löschen oder umbenennen &#8211; »remove()« und »rename()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_019.html#mjeb6e9131c2d7376dbfab9420a0559fa0" class="navnav">16.19.1 remove()</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_019.html#mj5564238174b6c560d0409983272fa1d7" class="navnav">16.19.2 rename()</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_020.html#mja35b620e756af1c2acf5ccb82df1cd9c" class="navnav">16.20 Pufferung einstellen &#8211; »setbuf()« und »setvbuf()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_020.html#mj54ba9ff884754344acb66e0837596eec" class="navnav">16.20.1 Die Funktion »setbuf()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_020.html#mj74946a47f21ad8b26c582ac69a6658a2" class="navnav">16.20.2 Die Funktion »setvbuf()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_021.html#mj09ca7770a0ca8ecf6fa3cf65767b6e57" class="navnav">16.21 Temporäre Dateien erzeugen &#8211; »tmpfile()« und »tmpnam()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_021.html#mj5d2ddd68145a4793357b870f86aeb59a" class="navnav">16.21.1 »mkstemp()« &#8211; sichere Alternative für Linux/UNIX (nicht ANSI C)</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_022.html#mj12d4ebf54db5fda9b12dcd0fc600752c" class="navnav">16.22 Fehlerbehandlung</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_022.html#mj160b145eef582c2b6ddb4fce84e212fc" class="navnav">16.22.1 Fehlerausgabe mit »perror()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_022.html#mje4fc460b402115101b12ed2250722d87" class="navnav">16.22.2 Fehlerausgabe mit »strerror()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_023.html#mje9fb10a998a98c8cd031e1e59f80a1af" class="navnav">16.23 Formatiert in einen String schreiben und formatiert aus einem String lesen &#8211; »sscanf()« und »sprintf()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_024.html#mj64f40d0984e53683e2c8ed717afc51da" class="navnav">16.24 Byte- und wide-orientierter Stream</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_025.html#mj58df345d1ac6e3744ac35f1c082cee0c" class="navnav">16.25 Ein fortgeschrittenes Thema</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_026.html#mj82df2f6904c6973c991d7b83f8fbbefd" class="navnav">16.26 Low-Level-Datei-I/O-Funktionen (nicht ANSI C)</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_026.html#mj91ce7d771683503e8ebb083939a5f0ce" class="navnav">16.26.1 Datei öffnen &#8211; »open()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_026.html#mj67da1cd8132864af50120ea4037c9cac" class="navnav">16.26.2 Datei schließen &#8211; »close()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_026.html#mjc13c6661f7e8039d407be6afe6d36f0f" class="navnav">16.26.3 Datei erzeugen &#8211; »creat()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_026.html#mjcc7066e693d758cfc5fd93b9e47a84e4" class="navnav">16.26.4 Schreiben und Lesen &#8211; »write()« und »read()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_026.html#mj4bb8f95e72dd7e438479e91bb8c02c1e" class="navnav">16.26.5 File-Deskriptor positionieren &#8211; »lseek()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_026.html#mj32b392fdf813e7ba5f00d33a95179eac" class="navnav">16.26.6 File-Deskriptor von einem Stream &#8211; »fileno()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_026.html#mj75c334204d8e6c4dd9bf1c6fd20669f9" class="navnav">16.26.7 Stream von File-Deskriptor &#8211; »fdopen()«</a></strong></td>
</tr>
</table><br></td>
</tr>
</table>
<table width="100%" cellpadding="20" cellspacing="0" border="0" bgcolor="#eeeeee">
<tr>
<td><div class="main"><a id="mjd6205d099779f805fd974466f81d3e86" name="mjd6205d099779f805fd974466f81d3e86"></a><a name="t21"></a><a name="t2t31"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div>
<h2 class="t2"><span class="cfett">16.17</span><span class="cfett"> Blockweise lesen und schreiben &#8211; »fread()« und »fwrite()«</span>  <a href="#t2t32"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><img src="common/15x15leer.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></h2>
<p>Diese beiden Funktionen lassen sich nicht so recht in ein Thema der Datei-E/A einordnen &#8211; weder in den höheren Standardfunktionen (<span class="ckursiv">High Level</span>) noch in den niedrigeren Funktionen (<span class="ckursiv">Low-Level</span>). Mit <span class="clisting">fread()</span> und <span class="clisting">fwrite()</span> wird eine Datei nicht als strukturierte Textdatei und auch nicht als unformatierter Bytestrom betrachtet. Die Dateien werden im Binärmodus bearbeitet und haben eine feste Satzstruktur. Das heißt, die Funktionen <span class="clisting">fread()</span> und <span class="clisting">fwrite()</span> tun nichts anderes, als ganze Blöcke binär zu lesen und zu schreiben.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellenkopf"><span class="cfett">Hinweis</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p class="BStandard">Die Bezeichnungen <span class="ckursiv">Textmodus</span> und <span class="ckursiv">Binärmodus</span> können hierbei recht verwirrend sein. ANSI C erlaubt beide Möglichkeiten, eine Datei zu öffnen. Informationen können somit im Binärmodus oder Textmodus geschrieben oder gelesen werden. Eine Textdatei beispielsweise können Sie also im Binärmodus öffnen. Ebenso lässt sich ein Text im Binärmodus abspeichern. Sie können auch die Funktion <span class="clisting">fgetc()</span> oder <span class="clisting">getc()</span> verwenden, um eine Datei mit binären Daten zu kopieren.</p>
</td>
</tr>
</table><br><p>Das Gute an diesen beiden Funktionen ist ihre einfache Anwendung. Der Nachteil ist aber, dass die Daten der Datei, die <span class="clisting">fwrite()</span> schreibt, nicht portabel, sondern plattformabhängig sind. Wollen Sie zum Beispiel mit diesen Funktionen Hauptspeicherinhalte direkt in eine Datei schreiben, könnten aufgrund eines anderen Alignments Probleme auftreten. Dies kommt daher, weil ein Member-Alignment in anderen Strukturen eine andere Byte-Reihenfolge bei Ganzzahlen oder eine unterschiedliche interne Darstellung von Fließkommazahlen haben könnte. Dieses Problem kann schon bei unterschiedlichen Compilern auftreten! Ist es also wichtig, dass die Daten auch auf anderen Systemen gelesen werden können, haben Sie folgende zwei Möglichkeiten:</p>
<ul class="gp">
<li>Die bessere Lösung wäre es, eine einfache ASCII-Textdatei zu verwenden, die mit <span class="clisting">fprintf()</span> geschrieben und mit <span class="clisting">fscanf()</span> gelesen wird. Ähnlich wird übrigens auch bei Netzwerkprotokollen vorgegangen. Zwar sind Textdateien meistens größer, und die Ein-/Ausgabe läuft ein wenig langsamer ab, aber der Vorteil, die einfachere Handhabung der Daten, macht diese Nachteile wieder wett.</li>
</ul>
<ul class="gp">
<li>Sie überprüfen, ob es sich dabei um eine Big-Endian- oder Little-Endian-Maschine handelt.</li>
</ul>
<p>Diese Funktionen ergänzen das Sortiment der Lese- und Schreibfunktionen hervorragend. Denn mit <span class="clisting">fgets()</span> und <span class="clisting">fputs()</span> lassen sich, wegen der besonderen Bedeutung der Zeichen <span class="clisting">'\0'</span> und <span class="clisting">'\n'</span> in ihnen, schlecht ganze Blöcke von Daten lesen bzw. schreiben. Ebenso ist es nicht sinnvoll, Daten Zeichen für Zeichen zu verarbeiten, wie dies bei den Funktionen <span class="clisting">fputc()</span> und <span class="clisting">fgetc()</span> geschieht. Außerdem ist es naheliegend, dass sich diese beiden Funktionen hervorragend zum Lesen und Schreiben von Strukturen eignen.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellenkopf"><span class="cfett">Hinweis</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p class="BStandard">Da <span class="clisting">fread()</span> und <span class="clisting">fwrite()</span> nicht mit Zeichen bzw. Strings arbeiten, gibt es keine Funktion für breite Zeichen zu ihnen.</p>
</td>
</tr>
</table><br><a id="mj650d52c45fd8c662ee1fc078a23487ef" name="mj650d52c45fd8c662ee1fc078a23487ef"></a><a name="t31"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div><a name="t2t32"></a><h3 class="t3"><span class="cfett">16.17.1</span><span class="cfett"> Blockweise lesen &#8211; »fread()«</span>  <a href="#t2t33"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t31"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Die Syntax der Funktion lautet wie folgt:</p>
<div class="listing"><pre class="prettyprint">size_t fread(void *puffer, size_t blockgroesse,
             size_t blockzahl, FILE *datei);</pre></div>
<p><span class="clisting">fread()</span> liest <span class="clisting">blockzahl</span>-Speicherobjekte, von denen jedes die Größe von <span class="clisting">blockgroesse</span> Bytes hat, aus dem Stream <span class="clisting">datei</span>, der zuvor geöffnet wurde, in die Adresse von <span class="clisting">puffer</span>. Für <span class="clisting">puffer</span> muss dementsprechend viel Platz zur Verfügung stehen. Der Rückgabewert ist die Anzahl der gelesenen Speicherobjekte. Ist die Anzahl kleiner als <span class="clisting">blockzahl</span>, wurde entweder das Dateiende erreicht, oder es trat ein Fehler auf.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellenkopf"><span class="cfett">Hinweis</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p class="BStandard"><span class="clisting">size_t</span> ist ein primitiver Systemdatentyp, der in der Headerdatei &lt;stddef.h&gt; definiert ist. Der maximale Wert des Typ ist implementierungsabhängig. Meistens ist dieser Typ allerdings als <span class="clisting">unsigned</span> <span class="clisting">int</span> implementiert).</p>
</td>
</tr>
</table><br><div class="bildbox">
<p><a name="IDATNUQ"></a><a onClick="OpenWin('bilder/16_006.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein16_006.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 16.6    </strong>Blockweises Lesen mit »fread()«</p>
<p>Nehmen wir an, wir haben eine Datei namens <span class="ckursiv">wert.dat,</span> deren Inhalte aus Integerwerten bestehen. Werden z. B. die ersten zehn Werte benötigt, sieht der Quellcode folgendermaßen aus:</p>
<div class="listing"><pre class="prettyprint">/* fread.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void) {
   int puffer[10];
   FILE *quelle;
   int i;

   quelle = fopen("wert.dat", "r+b");
   if(quelle != NULL)
      fread(&amp;puffer, sizeof(int), 10, quelle);

   for(i = 0; i &lt; 10; i++)
      printf("Wert %d = %d\n", i, puffer[i]);
 return EXIT_SUCCESS;
}</pre></div>
<p>Folgende Zeile soll wie oben interpretiert werden:</p>
<div class="listing"><pre class="prettyprint">fread(&amp;puffer, sizeof(int), 10, quelle);</pre></div>
<p><span class="clisting">fread()</span> liest <span class="clisting">10</span> Datenobjekte mit der Größe von je <span class="clisting">sizeof(int)</span> Bytes aus dem Stream <span class="clisting">quelle</span> in die Adresse von <span class="clisting">puffer</span>.</p>
<p>Ein wenig undurchsichtig dürfte der Parameter <span class="clisting">void *puffer</span> bei <span class="clisting">fread()</span> und <span class="clisting">fwrite()</span> erscheinen. Mit dem <span class="clisting">void</span>-Zeiger haben Sie den Vorteil, dass diesem Parameter ein Zeiger beliebigen Datentyps übergeben werden kann. In Kapitel 12, »Zeiger (Pointer)«, haben wir dies bereits durchgenommen.</p><a id="mj72d8bcd5c9fd159c248b24caf558e345" name="mj72d8bcd5c9fd159c248b24caf558e345"></a><a name="t32"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div><a name="t2t33"></a><h3 class="t3"><span class="cfett">16.17.2</span><span class="cfett"> Blockweise schreiben &#8211; »fwrite()«</span>  <a href="#t2t34"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t32"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Kommen wir jetzt zur Funktion <span class="clisting">fwrite()</span>:</p>
<div class="listing"><pre class="prettyprint">size_t fwrite(const void *puffer,size_t blockgroesse,
              size_t blockzahl, FILE *datei);</pre></div>
<p>Mit <span class="clisting">fwrite()</span> werden <span class="clisting">blockzahl</span>-Speicherobjekte, von denen jedes <span class="clisting">blockgroesse</span> Bytes groß ist, von der Adresse <span class="clisting">puffer</span> in den Ausgabe-Stream <span class="clisting">datei</span> geschrieben. Der Rückgabewert ist auch hier die Anzahl der geschriebenen Speicherobjekte. Ist die Anzahl kleiner als <span class="clisting">blockzahl</span>, dann ist ein Fehler aufgetreten.</p>
<div class="bildbox">
<p><a name="IDARYUQ"></a><a onClick="OpenWin('bilder/16_007.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein16_007.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 16.7    </strong>Blockweise schreiben mit »fwrite()«</p>
<p>Wieder ein Beispiel:</p>
<div class="listing"><pre class="prettyprint">struct {
   char name[20];
   char vornam[20];
   char wohnort[30];
   int alter;
   int plz;
   char Strasse[30];
} adressen;

FILE *quelle;

strcpy(adressen.name, "Barack");
strcpy(adressen.vornam, "Obama");
strcpy(adressen.wohnort, "Washington D.C");
adressen.alter = 55;
adressen.plz = 23223;
...
if((quelle=fopen("adres.dat", "w+b")) == NULL)
...
fwrite(&amp;adressen, sizeof(struct adressen), 1, quelle);</pre></div>
<p>Hier wird mit <span class="clisting">fwrite()</span> aus der Adresse <span class="clisting">adressen</span> ein Speicherobjekt mit der Größe von <span class="clisting">sizeof(struct adressen)</span> Bytes in den Stream <span class="clisting">quelle</span> geschrieben.</p>
<p>Als Beispiel zu den Funktionen <span class="clisting">fread()</span> und <span class="clisting">fwrite()</span> folgt ein kleines Adressenverwaltungsprogramm ohne irgendwelche besonderen Funktionen, um nicht vom eigentlichen Thema abzulenken:</p>
<div class="listing"><pre class="prettyprint">/* fread_fwrite.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct {
   char vorname[20];
   char nachname[30];
   char strasse[30];
   char hausnummer[5];
   char plz[7];
   char ort[30];
   char sternzeichen[30];
   char alter[3];
} adressen;

void speichern(void) {
   FILE *save = fopen("adressen.dat","r+b");
   if( NULL == save ) {
      save = fopen("adressen.dat","w+b");
      if( NULL == save ) {
         fprintf(stderr,"Kann \"adressen.dat\" nicht öffnen!\n");
         return;
      }
   }
   /* FILE-Zeiger save auf das Ende der Datei setzen */
   fseek(save, 0, SEEK_END);

   /* Wir schreiben eine Adresse ans Ende von "adressen.dat". */
   if(fwrite(&amp;adressen, sizeof(adressen), 1, save) != 1) {
      fprintf(stderr, "Fehler bei fwrite...!!!\n");
      return;
   }
   /* Wir geben unseren FILE-Zeiger wieder frei. */
   fclose(save);
}

void ausgabe(void) {
   FILE *output = fopen("adressen.dat","r+b");
   if( NULL == output ) {
      fprintf(stderr,"Kann \"adressen.dat\" nicht öffnen!\n");
      return;
   }
   /* Wir lesen alle Adressen aus "adressen.dat". */
   while(fread(&amp;adressen, sizeof(adressen), 1, output) == 1) {
      printf("Vorname...........: %s",adressen.vorname);
      printf("Nachname..........: %s",adressen.nachname);
      printf("Strasse...........: %s",adressen.strasse);
      printf("Hausnummer........: %s",adressen.hausnummer);
      printf("Postleitzahl......: %s",adressen.plz);
      printf("Ort...............: %s",adressen.ort);
      printf("Sternzeichen......: %s",adressen.sternzeichen);
      printf("Alter.............: %s",adressen.alter);
      printf("\n\n");
   }
   fclose(output);
}
void eingabe(void) {
   printf("Vorname...........:");
   fgets(adressen.vorname, sizeof(adressen.vorname), stdin);
   printf("Nachname..........:");
   fgets(adressen.nachname, sizeof(adressen.nachname),stdin);
   printf("Strasse...........:");
   fgets(adressen.strasse, sizeof(adressen.strasse), stdin);
   printf("Hausnummer........:");
   fgets(adressen.hausnummer,sizeof(adressen.hausnummer),stdin);
   printf("Postleitzahl......:");
   fgets(adressen.plz, sizeof(adressen.plz), stdin);
   printf("Ort...............:");
   fgets(adressen.ort, sizeof(adressen.ort), stdin);
   printf("Sternzeichen......:");
   fgets(adressen.sternzeichen,sizeof(adressen.sternzeichen),
      stdin );
   printf("Alter.............:");
   fgets(adressen.alter, sizeof(adressen.alter), stdin);
   speichern();
}

int main(void) {
   int wahl;

   do {
      printf("Was wollen Sie machen:\n\n");
      printf("-1- Neuen Datensatz hinzufuegen\n");
      printf("-2- Alle Datensaetze ausgeben\n");
      printf("-3- Programm beenden\n\n");
      printf("Ihre Auswahl : ");
      do {
         scanf("%d",&amp;wahl);
      } while(getchar() != '\n');
      switch(wahl) {
         case 1 : eingabe();        break;
         case 2 : ausgabe();        break;
         case 3 : printf("...Programm wird beendet\n");
                  break;
         default: printf("&gt;&gt;%d&lt;&lt; ???\n",wahl);
      }
   } while(wahl != 3);
   return;
}</pre></div>
<p>Zuerst wurde eine Struktur mit dem Namen <span class="clisting">adressen</span> deklariert. In der Funktion <span class="clisting">speichern()</span> wird, falls vorhanden, die Datei <span class="ckursiv">adressen.dat</span> geöffnet. Ansonsten wird diese Datei erstellt:</p>
<div class="listing"><pre class="prettyprint">   FILE *save = fopen("adressen.dat","r+b");
   if( NULL == save ) {
      save = fopen("adressen.dat","w+b");
      if( NULL == save ) {</pre></div>
<p>Gleich darauf wird der Stream <span class="clisting">save</span> an das Ende der Datei <span class="ckursiv">adressen.dat</span> positioniert:</p>
<div class="listing"><pre class="prettyprint">fseek(save, 0, SEEK_END);</pre></div>
<p>Jetzt kann der Adressensatz in die Datei geschrieben werden:</p>
<div class="listing"><pre class="prettyprint">if(fwrite(&amp;adressen, sizeof(adressen), 1, save) != 1)</pre></div>
<p>Nochmals eine Erklärung von <span class="clisting">fwrite()</span>:</p>
<ul class="gp">
<li><span class="clisting">&amp;adressen</span> &#8211; Anfangsadresse der Struktur <span class="clisting">adressen</span>, welche am Programmbeginn deklariert und in der Funktion <span class="clisting">eingabe()</span> mit Werten initialisiert wurde</li>
</ul>
<ul class="gp">
<li><span class="clisting">sizeof(struct adressen)</span> &#8211; Größe (Blockgröße) in Byte, die vorgibt, wie viel auf einmal in den Stream <span class="clisting">save</span> geschrieben werden soll</li>
</ul>
<ul class="gp">
<li><span class="clisting">1</span> &#8211; Anzahl der Blöcke von der Größe <span class="clisting">sizeof(adressen)</span>, die in den Stream <span class="clisting">save</span> geschrieben werden</li>
</ul>
<ul class="gp">
<li><span class="clisting">save</span> &#8211; Stream, der zuvor geöffnet wurde, und in den geschrieben wird</li>
</ul>
<p>Diese Anweisung wurde in eine <span class="clisting">if</span>-Bedingung gepackt, die eine Fehlerausgabe vornimmt, falls weniger als ein Block geschrieben wird. Mit der Funktion <span class="clisting">ausgabe()</span> wird diese Datei jetzt über <span class="clisting">fread()</span> blockweise ausgelesen und der Inhalt auf dem Bildschirm ausgegeben:</p>
<div class="listing"><pre class="prettyprint">while(fread(&amp;adressen, sizeof(adressen), 1, output) == 1)</pre></div>
<p>Es wird so lange ausgelesen, bis kein ganzer Block der Größe <span class="clisting">sizeof(adressen)</span> mehr vorhanden ist. Auch hierzu bekommen Sie eine genauere Erläuterung von <span class="clisting">fread()</span>:</p>
<ul class="gp">
<li><span class="clisting">&amp;adressen</span> &#8211; Hierhin wird der Block der Größe <span class="clisting">sizeof(adressen)</span>, auf die der <span class="clisting">FILE</span>-Zeiger <span class="clisting">output</span> zeigt, »geschoben«. Natürlich handelt es sich auch hier um die Struktur <span class="clisting">adressen</span>, die durch den Aufruf von <span class="clisting">fread()</span> mit dementsprechenden Werten initialisiert wird.</li>
</ul>
<ul class="gp">
<li><span class="clisting">sizeof(adressen)</span> &#8211; Größe des Blocks, der gelesen werden soll</li>
</ul>
<ul class="gp">
<li><span class="clisting">1</span> &#8211; Anzahl der Blöcke, die gelesen werden</li>
</ul>
<ul class="gp">
<li><span class="clisting">output</span> &#8211; Stream, aus dem gelesen wird</li>
</ul><a id="mjdcd1441c7ba913a6400250870e2e06cd" name="mjdcd1441c7ba913a6400250870e2e06cd"></a><a name="t33"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div><a name="t2t34"></a><h3 class="t3"><span class="cfett">16.17.3</span><span class="cfett"> Big Endian und Little Endian</span>  <img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"><a href="#t2t33"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Ich habe bereits erwähnt, dass die Funktionen <span class="clisting">fread()</span> und <span class="clisting">fwrite()</span> nicht portabel und somit plattformabhängig sind. Sollten Sie also Programme schreiben wollen, die auf den verschiedensten Systemen laufen sollen, bleibt Ihnen nur die Wahl, diese Funktionen nicht zu verwenden, oder Sie finden heraus, auf welchem System genau sie laufen sollen. Unterschieden werden die Systeme dabei nach <span class="ckursiv">Little Endian</span> und <span class="ckursiv">Big Endian</span>. Little Endian und Big Endian sind zwei Methoden, wie die einzelnen Bytes im Speicher angeordnet sind. Little Endian und Big Endian unterscheiden sich durch die Anordnung des <span class="ckursiv">most significant byte</span> und des <span class="ckursiv">least significant byte</span>. Bei einer Word-Größe der CPU von vier Bytes wird das rechte Ende als <span class="ckursiv">least significant byte</span> und das linke Ende als <span class="ckursiv">most significant byte</span> bezeichnet. Das <span class="ckursiv">least significant byte</span> stellt dabei die niedrigeren Werte und das <span class="ckursiv">most significant byte</span> die größeren Werte in einem Word dar. Als Beispiel dient jetzt folgende Hex-Zahl:</p>
<div class="listing"><pre class="prettyprint">22CCDDEE</pre></div>
<p>Auf den unterschiedlichen Systemen wird diese Hex-Zahl im Speicher folgendermaßen abgelegt:</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter"><p class="ptabunter"><strong>Tabelle 16.7    </strong>Little Endian und Big Endian im Vergleich</p>
</caption>
<tr>
<td class="tabellenkopf"><span class="cfett">Adresse</span>
</td>
<td class="tabellenkopf"><span class="cfett">0x12345</span>
</td>
<td class="tabellenkopf"><span class="cfett">0x12346</span>
</td>
<td class="tabellenkopf"><span class="cfett">0x12347</span>
</td>
<td class="tabellenkopf"><span class="cfett">0x12348</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p>Big Endian</p>
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">22</pre></div>
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">CC</pre></div>
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">DD</pre></div>
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">EE</pre></div>
</td>
</tr>
<tr>
<td class="tabellentext">
<p>Little Endian</p>
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">EE</pre></div>
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">DD</pre></div>
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">CC</pre></div>
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">22</pre></div>
</td>
</tr>
</table><br><p>Um jetzt herauszufinden, auf was für einem System das Programm ausgeführt wird, müssen Sie diese Hex-Zahl in einen Speicher schreiben, der Platz für eine Wortbreite bietet und das erste Byte mithilfe von Bit-Operationen überprüfen. Hier sehen Sie das Listing dazu:</p>
<div class="listing"><pre class="prettyprint">/* endian.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
typedef unsigned int  WORD;
typedef unsigned char BYTE;

int main(void) {
   /* Word in den Speicher schreiben */
   WORD Word = 0x22CCDDEE;
   /* Zeiger auf ein Byte */
   BYTE *Byte;

   /* Word-Zeiger auf Byte-Zeiger casten */
   Byte = (BYTE *) &amp;Word;


/* Speicherinhalt nach Adressen von links nach rechts
 * ausgeben.
 * byte[0]byte[1]byte[2]byte[3]
 * 22     CC     DD     EE      Speicherinhalt bei Little Endian
 * EE     DD     CC     22      Speicherinhalt bei Big Endian
 */
   /* Ist Byte[0] == 11 */
   if(Byte[0] == ((Word &gt;&gt;  0) &amp; 0xFF))
      printf("Little Endian Architecture\n");
   /* oder ist Byte[0] == CC */
   if(Byte[0] == ((Word &gt;&gt; 24) &amp; 0xFF))
      printf("Big Endian Architecture\n");
   return EXIT_SUCCESS;
}</pre></div>
<p>Mit</p>
<div class="listing"><pre class="prettyprint">if(Byte[0] == ((Word &gt;&gt;  0) &amp; 0xFF))</pre></div>
<p>werden die ersten acht Bits (ein Byte) mithilfe einer Maske (<span class="clisting">FF</span> == 256 == 1 Byte) gezielt getestet. Werden bei dem Ausdruck (<span class="clisting">(Word &gt;&gt; 0) &amp; 0xFF)</span>) praktisch keine Bits auf 0 gesetzt und stimmt danach der ausgewertete Ausdruck mit <span class="clisting">Byte[0]</span> überein, haben Sie ein Little-Endian-System. Bei der zweiten Bedingung ist es dasselbe, nur wird dabei das vierte Byte (d.  h. das 24. bis 32. Bit) verwendet. Zu den Little-Endian-Systemen gehören z. B.:</p>
<ul class="gp">
<li>Intel-CPUs</li>
</ul>
<ul class="gp">
<li>DEC Alpha</li>
</ul>
<ul class="gp">
<li>VAX</li>
</ul>
<p>Big-Endian-Systeme sind zum Beispiel:</p>
<ul class="gp">
<li>Motorola MC68000 (Amiga, Atari)</li>
</ul>
<ul class="gp">
<li>SPARC CPUs (SUN)</li>
</ul>
<ul class="gp">
<li>IBM PowerPC</li>
</ul>
<p>Einen faden Nachgeschmack hat diese Methode allerdings dann doch. Jetzt wissen Sie zwar, ob es sich um ein Little- oder Big-Endian-System handelt, aber nun müssen Sie sich dennoch selbst darum kümmern, dass die einzelnen Bytes richtig gelesen und geschrieben werden. Damit ist gemeint, dass Sie die Bits selbst verschieben müssen. Aber dies ist ein Thema, das den Rahmen dieses Buchs sprengen würde.</p><br><hr><a name="kommentar"></a><h3>Ihr Kommentar</h3>
                       Wie hat Ihnen das &lt;openbook&gt; gefallen? Wir freuen uns immer über Ihre freundlichen und kritischen Rückmeldungen.
                       <!--<form action="http://www.galileo-press.de/feedback/openbook" method="post" style="text-align: center; margin-top: 10px;"><input type="hidden" name="openbookurl" value="http://openbook.galileocomputing.de/c_von_a_bis_z/016_c_ein_ausgabe_funktionen_017.htm"><input type="hidden" name="buchtitel" value="C von A bis Z"><input type="hidden" name="Kapitel" value="16.17 Blockweise lesen und schreiben &#8211; »fread()« und »fwrite()«"><table border="0">
<tr>
<td><label for="name">Name</label><br></td>
<td><input type="text" name="name" id="name" size="40"><br></td>
</tr>
<tr>
<td><label for="email">E-Mail</label><br></td>
<td><input type="text" name="email" id="email" size="40"><br></td>
</tr>
<tr>
<td valign="top"><label for="comment">Ihr Kommentar</label><br></td>
<td><textarea name="comment" id="comment" rows="10" cols="40"></textarea><br></td>
</tr>
<tr>
<td>
</td>
<td><input type="submit" value="Kommentar absenden"></td>
</tr>
</table>
</form>--><a href="https://www.rheinwerk-verlag.de/feedback/produkt/2132/">>> Zum Feedback-Formular</a>
</div></td>
</tr>
</table></td>
</tr>
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a href="016_c_ein_ausgabe_funktionen_016.html" class="navnav"> &lt;&lt;   zurück</a></td>
<td width="49%"><div align="center"><a class="navnav" href="#">&lt;top&gt;</a></div></td>
<td align="right" width="25%"><div align="right"><a href="016_c_ein_ausgabe_funktionen_018.html" class="navnav">vor   &gt;&gt; </a></div></td>
</tr>
</table></td>
</tr>
</table>
</div></td>
<td width="10" valign="top">&nbsp;&nbsp;</td>
<td width="160" valign="top">
<table border="0" cellpadding="0" cellspacing="0" width="160">
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="tbl2" height="20" colspan="2">
&nbsp;<a href="https://www.rheinwerk-verlag.de/?GPP=opc3" class="nav">
<strong>Zum Katalog</strong></a>
</td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2">
<img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td><a href="https://www.rheinwerk-verlag.de/c-von-a-bis-z_2132/?GPP=opc3">
	<img src="common/1411.gif" width="117" height="167" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C von A bis Z" title="Zum Katalog: C von A bis Z">
<br /><br /><strong>&nbsp;C von A bis Z</strong><br /><img src="common/pfeil_rechts5.gif" border="0" alt="">Jetzt&nbsp;bestellen</a><br /><br />
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="tbl2" height="20" colspan="2"><a href="#kommentar" class="nav"><strong>&nbsp;Ihre Meinung?</strong></a>
</td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td>Wie hat Ihnen das &lt;openbook&gt; gefallen?<br /><a href="#kommentar"><img src="common/pfeil_rechts5.gif" border="0" alt="">Ihre Meinung</a>
<br /><br /></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="tbl2" height="20" colspan="2">&nbsp;<a href="https://www.rheinwerk-verlag.de/?GPP=opc3" class="nav"><strong>Buchtipps</strong></a></td>
</tr>
<tr> 
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="https://www.rheinwerk-verlag.de/cc_3536/?GPP=opc3">
<img src="common/2757.gif" width="69" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C/C++" title="Zum Katalog: C/C++"><br /><br /><br /><br /><br /><br /><br />&nbsp;C/C++</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="https://www.rheinwerk-verlag.de/einstieg-in-c_3557/?GPP=opc3">
<img src="common/2793.gif" width="74" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Einstieg in C" title="Zum Katalog: Einstieg in C"><br /><br /><br /><br /><br /><br /><br />&nbsp;Einstieg in C</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="https://www.rheinwerk-verlag.de/schrodinger-programmiert-c_2853/?GPP=opc3">
<img src="common/1756.gif" width="85" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Schrödinger programmiert C++" title="Zum Katalog: Schrödinger programmiert C++"><br /><br /><br /><br /><br /><br /><br />&nbsp;Schrödinger<br />&nbsp;programmiert C++</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="https://www.rheinwerk-verlag.de/c_3278/?GPP=opc3">
<img src="common/2021.gif" width="69" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C++ Handbuch" title="Zum Katalog: C++ Handbuch"><br /><br /><br /><br /><br /><br /><br />&nbsp;C++ Handbuch</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="https://www.rheinwerk-verlag.de/it-handbuch-fur-fachinformatiker_3329/?GPP=opc3">
<img src="common/2234.gif" width="78" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: IT-Handbuch für Fachinformatiker" title="Zum Katalog: IT-Handbuch für Fachinformatiker"><br /><br /><br /><br /><br /><br /><br />&nbsp;IT-Handbuch für<br />&nbsp;Fachinformatiker</a><br /><br /></td>
</tr>
</table></td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="tbl2" height="20" colspan="2"><strong>&nbsp;Shopping</strong></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td><b>Versandkostenfrei</b> bestellen in Deutschland und &Ouml;sterreich<br /><a href="https://www.rheinwerk-verlag.de/hilfe/bestellung_6?GPP=opc3"><img src="common/pfeil_rechts5.gif" border="0" alt="Info">Info</a><br /><br /></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table><br><br><hr width="70%" align="center">
<div align="center">
<p class="standard"><strong>Copyright © Rheinwerk Verlag GmbH 2009</strong><br>
        Für Ihren privaten Gebrauch dürfen Sie die Online-Version natürlich ausdrucken.
        Ansonsten unterliegt das &lt;openbook&gt; denselben Bestimmungen, wie die
        gebundene Ausgabe: Das Werk einschließlich aller seiner Teile ist urheberrechtlich
        geschützt. Alle Rechte vorbehalten einschließlich der Vervielfältigung, Übersetzung,
        Mikroverfilmung sowie Einspeicherung und Verarbeitung in elektronischen Systemen.</p><br><a href="https://www.rheinwerk-verlag.de/">[Rheinwerk Computing]</a><br><br>
      Rheinwerk Verlag GmbH, Rheinwerkallee 4, 53227 Bonn, Tel.: 0228.42150.0, Fax 0228.42150.77, <a href="mailto:service@rheinwerk-verlag.de">service@rheinwerk-verlag.de</a></div><br><br></body>

<!-- Mirrored from openbook.rheinwerk-verlag.de/c_von_a_bis_z/016_c_ein_ausgabe_funktionen_017.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 23 Jun 2017 19:47:51 GMT -->
</html>
