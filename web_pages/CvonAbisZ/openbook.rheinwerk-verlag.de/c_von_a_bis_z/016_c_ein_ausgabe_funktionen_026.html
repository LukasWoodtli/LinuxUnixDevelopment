<html>

<!-- Mirrored from openbook.rheinwerk-verlag.de/c_von_a_bis_z/016_c_ein_ausgabe_funktionen_026.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 23 Jun 2017 19:48:00 GMT -->
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Rheinwerk Computing :: C von A bis Z &ndash; 16.26 Low-Level-Datei-I/O-Funktionen (nicht ANSI C)</title>
<meta name="title" content="Rheinwerk Computing :: C von A bis Z - 16.26 Low-Level-Datei-I/O-Funktionen (nicht ANSI C)">
<meta name="author" content="J&uuml;rgen Wolf ">
<meta name="publisher" content="Rheinwerk Verlag GmbH 2009">
<meta name="copyright" content="Rheinwerk Verlag GmbH 2009">
<meta name="Description" content="C von A bis Z - Das umfassende Handbuch &ndash; 16.26 Low-Level-Datei-I/O-Funktionen (nicht ANSI C)">
<meta name="audience" content="Alle">
<meta name="robots" content="INDEX,FOLLOW">
<meta http-equiv="content-language" content="de">
<link rel="stylesheet" type="text/css" href="common/rw_open.css">
<link rel="prev" href="016_c_ein_ausgabe_funktionen_025.html">
<link rel="next" href="017_c_dateien_verzeichnisse_001.html"><script type="text/javascript"><!--
    function OpenWin(url,name,height,width)
    {
      var InfoWin = window.open(url,name,"directories=0,height="+height+",width=" + width + ",hotkeys=0,location=0,menubar=0,resizable=1,screenX=150,screenY=10,left=150,top=10,scrollbars=1,status=1,titlebar=0,toolbar=0");
      InfoWin.focus();
    }
    //--></script><link href="common/prettify.css" type="text/css" rel="stylesheet"><script type="text/javascript" src="common/prettify.js"></script></head>
<body vlink="#000099" link="#000099" alink="#000099" onload="prettyPrint()">
<table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#00549d">
<tr>
<td height="74" valign="bottom" colspan="2"><a href="https://www.rheinwerk-verlag.de/katalog/openbook?GPP=opc3"><img src="common/rw_openbook.gif" width="200" height="56" border="0" alt="Rheinwerk Computing < openbook >" title="Rheinwerk Computing < openbook >"></a></td>
<td width="80" height="74"><a href="https://www.rheinwerk-verlag.de/?GPP=opc3"><img src="common/rw_computing.gif" border="0" alt="Rheinwerk Computing - Professionelle Bücher. Auch für Einsteiger." title="Rheinwerk Computing - Professionelle Bücher. Auch für Einsteiger."></a></td>
</tr>
</table>
<div align="right"><a href="https://www.rheinwerk-verlag.de/?GPP=opc3" class="navnav">Professionelle Bücher. Auch für Einsteiger.</a></div><br><table class="tbl" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="190" valign="top">
<table class="tbl1" border="0" cellpadding="3" cellspacing="0" width="190" align="left">
<tr>
<td class="tbl2"><a class="nav" href="index-2.html#_top">Inhaltsverzeichnis</a></td>
</tr>
<tr>
<td><a class="navnav" href="000_c_vorwort_001.html#mj764cb3fd439d3b95d1843e7c7d17f235">Vorwort</a></td>
</tr>
<tr>
<td><a class="navnav" href="000_c_vorwort_gutachter_001.html#mj3d41cb339c9b2fc1d6e99cdaa93c3860">Vorwort des Gutachters</a></td>
</tr>
<tr>
<td><a class="navnav" href="001_c_einstieg_in_c_001.html#mja24d93ff97bb42dbebf4689160c45195">1 Einstieg in C</a></td>
</tr>
<tr>
<td><a class="navnav" href="002_c_das_erste_programm_001.html#mj2604a667cc98d3fa2178751273346b91">2 Das erste Programm</a></td>
</tr>
<tr>
<td><a class="navnav" href="003_c_grundlagen_001.html#mj7ac54ba315b94149806c1de3fc89ee7f">3 Grundlagen</a></td>
</tr>
<tr>
<td><a class="navnav" href="004_c_ein_ausgabe_001.html#mj20c131820fbfb1497afd796ee443599e">4 Formatierte Ein-/Ausgabe mit »scanf()« und »printf()«</a></td>
</tr>
<tr>
<td><a class="navnav" href="005_c_basisdatentypen_001.html#mjeda2957449ddc812dad62b400fe57752">5 Basisdatentypen</a></td>
</tr>
<tr>
<td><a class="navnav" href="006_c_operatoren_001.html#mjab3693b096d581607801a36ce88905fc">6 Operatoren</a></td>
</tr>
<tr>
<td><a class="navnav" href="007_c_typumwandlung_001.html#mj5c5e497ac2ab4367fe9df0ffd218cfca">7 Typumwandlung</a></td>
</tr>
<tr>
<td><a class="navnav" href="008_c_kontrollstrukturen_001.html#mjc7bf6f584a2fe20b4c5f6b16ba15d57d">8 Kontrollstrukturen</a></td>
</tr>
<tr>
<td><a class="navnav" href="009_c_funktionen_001.html#mj7893101be51aa469fe52334038acd465">9 Funktionen</a></td>
</tr>
<tr>
<td><a class="navnav" href="010_c_praeprozessor_001.html#mjacdd200a20163a4d3fa418b6cb95763e">10 Präprozessor-Direktiven</a></td>
</tr>
<tr>
<td><a class="navnav" href="011_c_arrays_001.html#mje29de26c54a3884f7316cbbb2a073ad8">11 Arrays</a></td>
</tr>
<tr>
<td><a class="navnav" href="012_c_zeiger_001.html#mjee28a882ef9125d2c4cc49121b2c65c1">12 Zeiger (Pointer)</a></td>
</tr>
<tr>
<td><a class="navnav" href="013_c_kommandozeilenargumente_001.html#mjf6a9e42fa3bc25b2b1e06270e7bf8f68">13 Kommandozeilenargumente</a></td>
</tr>
<tr>
<td><a class="navnav" href="014_c_dyn_speicherverwaltung_001.html#mj8d062301d2449b13710f1484d499cd9b">14 Dynamische Speicherverwaltung</a></td>
</tr>
<tr>
<td><a class="navnav" href="015_c_strukturen_001.html#mj5e146ba18168113a5c645cd2d07c4ec8">15 Strukturen</a></td>
</tr>
<tr>
<td><a class="navh" href="##mj136f9ac6b5b7c440aafe5010411ef011">16 Ein-/Ausgabe-Funktionen</a></td>
</tr>
<tr>
<td><a class="navnav" href="017_c_dateien_verzeichnisse_001.html#mj9f81aea722a9edb8d0080df81eb9402c">17 Attribute von Dateien und das Arbeiten mit Verzeichnissen (nicht ANSI C)</a></td>
</tr>
<tr>
<td><a class="navnav" href="018_c_stdarg_h_001.html#mj9d64febdc46a1375e5c4498b17154e30">18 Arbeiten mit variabel langen Argumentlisten &#8211; &lt;stdarg.h&gt;</a></td>
</tr>
<tr>
<td><a class="navnav" href="019_c_zeitroutinen_001.html#mj0a8102e96a1297bd767ac7274e069f0f">19 Zeitroutinen</a></td>
</tr>
<tr>
<td><a class="navnav" href="020_c_headerdateien_001.html#mjf3caede8ebd504dc6b7454b297c251e8">20 Weitere Headerdateien und ihre Funktionen (ANSI C)</a></td>
</tr>
<tr>
<td><a class="navnav" href="021_c_dyn_datenstrukturen_001.html#mja75ba2f4ab8f95e9e321d195c1e26d76">21 Dynamische Datenstrukturen</a></td>
</tr>
<tr>
<td><a class="navnav" href="022_c_algorithmen_001.html#mj07afe6f332eab2e8168da2f69f7b31c4">22 Algorithmen</a></td>
</tr>
<tr>
<td><a class="navnav" href="023_c_cgi_001.html#mj6c4219b4e615fa24deaa57d5c3d04db8">23 CGI mit C</a></td>
</tr>
<tr>
<td><a class="navnav" href="024_c_mysql_001.html#mj12dab301033f9fd856aa739270c45e08">24 MySQL und C</a></td>
</tr>
<tr>
<td><a class="navnav" href="025_c_netzwerkprogrammierung_001.html#mja8101c6e0e4cb2e6fd8312114dad30d7">25 Netzwerkprogrammierung und Cross&ndash;Plattform-Entwicklung</a></td>
</tr>
<tr>
<td><a class="navnav" href="026_c_paralleles_rechnen_001.html#mj710dc0ad851d57e60533f8797ff9c1e6">26 Paralleles Rechnen</a></td>
</tr>
<tr>
<td><a class="navnav" href="027_c_sicheres_programmieren_001.html#mj13eba8f9d68ac8414bffaa3a1b24ec31">27 Sicheres Programmieren</a></td>
</tr>
<tr>
<td><a class="navnav" href="028_c_weiterfuehrendes_001.html#mj3e65f750149ade087925f303b3871af9">28 Wie geht&#8217;s jetzt weiter?</a></td>
</tr>
<tr>
<td><a class="navnav" href="029_c_anhang_a_001.html#mjec9bf1c5e3fe2e46047c2f9c7aa9c531">A Operatoren</a></td>
</tr>
<tr>
<td><a class="navnav" href="030_c_anhang_b_001.html#mj803443bb6e7546011c48e6e57fbdbb64">B Die C-Standard-Bibliothek</a></td>
</tr>
<tr>
<td><a class="navnav" href="stichwort.html#_top">Stichwort</a></td>
</tr>
<!--<tr>
<td><br><a href="http://download.galileo-press.de/openbook/c_von_a_bis_z/galileocomputing_c_von_a_bis_z.zip" class="navnav"><strong>Download:</strong><br>- ZIP, ca. 10,3 MB</a></td>
</tr>-->
<tr>
<td><br><a href="https://www.rheinwerk-verlag.de/2132/?GPP=opc3" class="navnav">Buch bestellen</a></td>
</tr>
<tr>
<td><a class="navnav" href="#kommentar">Ihre Meinung?</a><br><br></td>
</tr>
</table>
</td>
<td width="10"><img src="common/spacer10.gif" width="10" height="10" alt="Spacer"></td>
<td width="85%" valign="top" align="center"><div align="center">
<table width="98%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a href="016_c_ein_ausgabe_funktionen_025.html" class="navnav"> &lt;&lt;   zurück</a></td>
<td width="49%"><div align="center"><a href="https://www.rheinwerk-verlag.de/?GPP=opc3" class="navnav">Rheinwerk Computing</a> / <a href="https://www.rheinwerk-verlag.de/openbook/?GPP=opc3" class="navnav">&lt;openbook&gt;</a> / <a href="index-2.html" class="navnav"> C von A bis Z</a></div></td>
<td align="right" width="25%"><div align="right"><a href="017_c_dateien_verzeichnisse_001.html" class="navnav">vor   &gt;&gt; </a></div></td>
</tr>
</table></td>
</tr>
<tr>
<td width="100%" valign="top"><table width="100%" border="0" cellpadding="10" cellspacing="0" class="box">
<tr>
<td colspan="2"><a href="https://www.rheinwerk-verlag.de/2132/?GPP=opc3" class="buchtitel">C von A bis Z</a><span class="autor"> von J&uuml;rgen Wolf </span><br><span class="untertitel">Das umfassende Handbuch</span></td>
</tr>
<tr>
<td valign="top" width="211"><dl>
<dt><a href="https://www.rheinwerk-verlag.de/2132/?GPP=opc3" class="navnav"><img src="common/9783836214117.gif" border="0" alt="Buch: C von A bis Z" title="Buch: C von A bis Z"></a></dt>
<dd><br><a href="https://www.rheinwerk-verlag.de/2132/?GPP=opc3"><span class="autor"><strong>C von A bis Z</strong><br>3., aktualisierte und erweiterte Auflage, geb., mit CD und Referenzkarte<br>1.190 S., 39,90 Euro<br>Rheinwerk Computing<br>ISBN 978-3-8362-1411-7</span></a></dd>
</dl></td>
<td width="80%"><table border="0">
<tr>
<td valign="baseline"><img src="common/pfeil_u.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="3" class="kap"><strong><a href="016_c_ein_ausgabe_funktionen_001.html#mj136f9ac6b5b7c440aafe5010411ef011" class="navnav">16 Ein-/Ausgabe-Funktionen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_001.html#mj4c867f68333349b78c5d61ab2e017aae" class="navnav">16.1 Was ist eine Datei?</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_002.html#mj7e0dfaa010e3c9ec2a3b039e54bce268" class="navnav">16.2 Formatierte und unformatierte Ein-/Ausgabe</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_003.html#mjc93191818792ac003a79b031035d4018" class="navnav">16.3 Standard-Streams</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_004.html#mj933d3cc5869070380c6a8d68958eed05" class="navnav">16.4 Höhere Ein-/Ausgabe-Funktionen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_005.html#mj47f082541eb4df9dbdcefdbc2775feae" class="navnav">16.5 Datei (Stream) öffnen &#8211; »fopen«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_005.html#mj2f57f419fdeadcd1c7dd4e001616d21a" class="navnav">16.5.1 Modus für »fopen()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_005.html#mjd78eb35b8f5e3230fb62a9823cb1801e" class="navnav">16.5.2 Maximale Anzahl geöffneter Dateien &#8211; »FOPEN_MAX«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_006.html#mja821f1d0ab158bed792eccc5f30e3f84" class="navnav">16.6 Zeichenweise lesen und schreiben &#8211; »getchar()« und »putchar()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_006.html#mj4097573a931a82cba06a1c2ce037325d" class="navnav">16.6.1 Ein etwas portableres »getch()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_007.html#mjc9c7a50e6c2ac045cd5fdedafb67251f" class="navnav">16.7 Zeichenweise lesen und schreiben &#8211; »putc()«/»fputc()« und »getc()«/»fgetc()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_008.html#mj13977630d07d7d1f3615135a518a478b" class="navnav">16.8 Datei (Stream) schließen &#8211; »fclose()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_009.html#mje5a9730700783816c72f0f4556b59d10" class="navnav">16.9 Formatiertes Einlesen/Ausgeben von Streams mit »fprintf()« und »fscanf()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_010.html#mja405f2e8d16be96b75ee88fcbe398615" class="navnav">16.10 Standard-Streams in C</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_010.html#mj9dbf91fb0f12de81b779d8be658b7b63" class="navnav">16.10.1 Standard-Streams umleiten</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_011.html#mjb930733ba3e062cb3df828cab6ac39b4" class="navnav">16.11 Fehlerbehandlung von Streams &#8211; »feof()«, »ferror()« und »clearerr()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_012.html#mj7d29d53b9da9d217f2f5187ea1184e86" class="navnav">16.12 Gelesenes Zeichen in die Eingabe zurückschieben &#8211; »ungetc()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_013.html#mj916b50e93a84be77b338cb8023b6fafc" class="navnav">16.13 (Tastatur-)Puffer leeren &#8211; »fflush()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_014.html#mjff798e62f1469fc3901b349f005d6547" class="navnav">16.14 Stream positionieren &#8211; »fseek()«, »rewind()« und »ftell()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_015.html#mjeedfe60fb34e4608925d9785db986435" class="navnav">16.15 Stream positionieren &#8211; »fsetpos()«, »fgetpos()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_016.html#mjb5f0f6be89b2708a1d3388f2266093e5" class="navnav">16.16 Zeilenweise Ein-/Ausgabe von Streams</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_016.html#mjceae94d455526a1bb0846ed53314fef2" class="navnav">16.16.1 Zeilenweise lesen mit »gets()«/»fgets()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_016.html#mj89d09323b58ff56fd8b314a2fe803d57" class="navnav">16.16.2 Zeilenweise schreiben mit »puts()«/»fputs()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_016.html#mj37828f5c575bb30773c771db5616949b" class="navnav">16.16.3 Zeilenweise vom Stream einlesen mit »getline()«
(nicht ANSI C)</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_016.html#mjcea47bd6d32a4a8f51be329a672845d7" class="navnav">16.16.4 Rezepte für zeilenweises Einlesen und Ausgeben</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_017.html#mjd6205d099779f805fd974466f81d3e86" class="navnav">16.17 Blockweise lesen und schreiben &#8211; »fread()« und »fwrite()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_017.html#mj650d52c45fd8c662ee1fc078a23487ef" class="navnav">16.17.1 Blockweise lesen &#8211; »fread()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_017.html#mj72d8bcd5c9fd159c248b24caf558e345" class="navnav">16.17.2 Blockweise schreiben &#8211; »fwrite()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_017.html#mjdcd1441c7ba913a6400250870e2e06cd" class="navnav">16.17.3 Big Endian und Little Endian</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_018.html#mjdea3be88c491b66e0c30cb6efbdf5b16" class="navnav">16.18 Datei (Stream) erneut öffnen &#8211; »freopen()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_019.html#mj90ce4661683446b0c5f4d0f8704358d3" class="navnav">16.19 Datei löschen oder umbenennen &#8211; »remove()« und »rename()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_019.html#mjeb6e9131c2d7376dbfab9420a0559fa0" class="navnav">16.19.1 remove()</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_019.html#mj5564238174b6c560d0409983272fa1d7" class="navnav">16.19.2 rename()</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_020.html#mja35b620e756af1c2acf5ccb82df1cd9c" class="navnav">16.20 Pufferung einstellen &#8211; »setbuf()« und »setvbuf()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_020.html#mj54ba9ff884754344acb66e0837596eec" class="navnav">16.20.1 Die Funktion »setbuf()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_020.html#mj74946a47f21ad8b26c582ac69a6658a2" class="navnav">16.20.2 Die Funktion »setvbuf()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_021.html#mj09ca7770a0ca8ecf6fa3cf65767b6e57" class="navnav">16.21 Temporäre Dateien erzeugen &#8211; »tmpfile()« und »tmpnam()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_021.html#mj5d2ddd68145a4793357b870f86aeb59a" class="navnav">16.21.1 »mkstemp()« &#8211; sichere Alternative für Linux/UNIX (nicht ANSI C)</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_022.html#mj12d4ebf54db5fda9b12dcd0fc600752c" class="navnav">16.22 Fehlerbehandlung</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_022.html#mj160b145eef582c2b6ddb4fce84e212fc" class="navnav">16.22.1 Fehlerausgabe mit »perror()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="016_c_ein_ausgabe_funktionen_022.html#mje4fc460b402115101b12ed2250722d87" class="navnav">16.22.2 Fehlerausgabe mit »strerror()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_023.html#mje9fb10a998a98c8cd031e1e59f80a1af" class="navnav">16.23 Formatiert in einen String schreiben und formatiert aus einem String lesen &#8211; »sscanf()« und »sprintf()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_024.html#mj64f40d0984e53683e2c8ed717afc51da" class="navnav">16.24 Byte- und wide-orientierter Stream</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="016_c_ein_ausgabe_funktionen_025.html#mj58df345d1ac6e3744ac35f1c082cee0c" class="navnav">16.25 Ein fortgeschrittenes Thema</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="#mj82df2f6904c6973c991d7b83f8fbbefd" class="navh">16.26 Low-Level-Datei-I/O-Funktionen (nicht ANSI C)</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj91ce7d771683503e8ebb083939a5f0ce" class="navh">16.26.1 Datei öffnen &#8211; »open()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj67da1cd8132864af50120ea4037c9cac" class="navh">16.26.2 Datei schließen &#8211; »close()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjc13c6661f7e8039d407be6afe6d36f0f" class="navh">16.26.3 Datei erzeugen &#8211; »creat()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjcc7066e693d758cfc5fd93b9e47a84e4" class="navh">16.26.4 Schreiben und Lesen &#8211; »write()« und »read()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj4bb8f95e72dd7e438479e91bb8c02c1e" class="navh">16.26.5 File-Deskriptor positionieren &#8211; »lseek()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj32b392fdf813e7ba5f00d33a95179eac" class="navh">16.26.6 File-Deskriptor von einem Stream &#8211; »fileno()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj75c334204d8e6c4dd9bf1c6fd20669f9" class="navh">16.26.7 Stream von File-Deskriptor &#8211; »fdopen()«</a></strong></td>
</tr>
</table><br></td>
</tr>
</table>
<table width="100%" cellpadding="20" cellspacing="0" border="0" bgcolor="#eeeeee">
<tr>
<td><div class="main"><a id="mj82df2f6904c6973c991d7b83f8fbbefd" name="mj82df2f6904c6973c991d7b83f8fbbefd"></a><a name="t21"></a><a name="t2t31"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div>
<h2 class="t2"><span class="cfett">16.26</span><span class="cfett"> Low-Level-Datei-I/O-Funktionen (nicht ANSI C)</span>  <a href="#t2t32"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><img src="common/15x15leer.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></h2>
<p>Mit den Funktionen der höheren Ebene (<span class="ckursiv">High-Level</span>) wurde auf die Daten mit einem hohen Abstraktionsniveau zugegriffen. Das bedeutet, die Daten eines Programms wurden formatiert ausgegeben oder eingelesen. Bei der niedrigeren Ebene (<span class="ckursiv">Low-Level</span>) wird auf einem tieferen Niveau gearbeitet. Der Zugriff auf die Daten findet als eine Folge von unstrukturierten Bytes statt und bietet somit die Möglichkeit, Bytesequenzen vorgegebener Länge einzulesen oder auszugeben. Nicht nur die Namen der Funktionen der höheren und der niedrigeren Ebene sind ähnlich, auch ihre Abarbeitung ist es &#8211; nur mit einem, aber sehr prinzipiellen Unterschied, der etwas verwirrend ist. Während beim High-Level-Dateizugriff mit einem <span class="clisting">FILE</span>-Zeiger (Stream) auf die Datei zugegriffen wird, geschieht dies auf der niedrigeren Ebene mit einem sogenannten File-Deskriptor. Dieser Deskriptor ist kein Zeiger wie bei der höheren Ebene, sondern ein normaler <span class="clisting">int</span>-Wert, der beim Öffnen einer Datei zurückgegeben wird.</p>
<p>Die höheren Dateifunktionen bauen auf den Funktionen der niedrigeren Ebene auf. Die niedrigere Ebene ist also die Grundlage der höheren Funktionen in der Standard-Bibliothek. Doch allein die Funktionen der niedrigeren Ebene arbeiten ungepuffert.</p>
<p>Wenn zum Beispiel Bibliotheksfunktionen wie <span class="clisting">printf()</span> oder <span class="clisting">scanf()</span> zum Aus- bzw. Eingeben benutzt werden, verwenden Sie eigentlich die Systemfunktionen <span class="clisting">write()</span> und <span class="clisting">read()</span>. Dies sind Funktionen (Systemfunktionen) im Low-Level-Bereich. Also ist es egal, ob <span class="clisting">fgets()</span>, <span class="clisting">fputs()</span>, <span class="clisting">gets()</span>, <span class="clisting">puts()</span>, <span class="clisting">putc()</span>, <span class="clisting">getc()</span> usw. eingesetzt werden, all diese Funktionen bauen auf Systemfunktionen auf.</p>
<p>Natürlich ist anzumerken, dass diese Funktionen der niedrigeren Ebene systemabhängig sind und somit nicht dem ANSI-C-Standard entsprechen können. Das heißt konkret, dass es Probleme mit der Portabilität der Programme geben kann.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellenkopf"><span class="cfett">Hinweis</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p class="BStandard">Bei Linux/UNIX-Betriebssystemen sind Low-Level-Funktionen direkte Schnittstellen zum System. Dateizugriffe mit diesen Funktionen realisieren direkt entsprechende Betriebssystemfunktionen (sogenannte <span class="ckursiv">System Calls</span>).</p>
</td>
</tr>
</table><br><a id="mj91ce7d771683503e8ebb083939a5f0ce" name="mj91ce7d771683503e8ebb083939a5f0ce"></a><a name="t31"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div><a name="t2t32"></a><h3 class="t3"><span class="cfett">16.26.1</span><span class="cfett"> Datei öffnen &#8211; »open()«</span>  <a href="#t2t33"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t31"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Öffnen Sie eine Datei mit der Funktion <span class="clisting">open()</span>, so wird der Datei ein Deskriptor &#8211; auch File-Deskriptor genannt &#8211; zugeordnet. Ein File-Deskriptor ist eine positive kleine Zahl, die vom Betriebssystem vergeben wird. Über diesen Deskriptor geben Sie an, ob gelesen oder geschrieben werden soll. Mit der Funktion <span class="clisting">open()</span> kann zudem auch gleich eine Datei angelegt werden. Hier sehen Sie die Syntax mit den dazugehörenden Headerdateien, die mit eingebunden werden müssen, für Linux/UNIX:</p>
<div class="listing"><pre class="prettyprint">#include &lt;fcntl.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;

int open(const char *pfad, int modus);
int open(const char *pfadname, int flags, mode_t zugriffsrechte);</pre></div>
<p>Die Syntax mit Headerdateien für Windows/MS-DOS sieht so aus:</p>
<div class="listing"><pre class="prettyprint">#include &lt;fcntl.h&gt;
#include &lt;io.h&gt;
#include &lt;sys\stat.h&gt;

int open(const char *pfad, int modus);
int open(const char *pfadname, int flags, mode_t zugriffsrechte);</pre></div>
<p>Als Pfadangabe müssen Sie den absoluten oder relativen Pfad der Datei angeben, die geöffnet werden soll. Da der Prototyp (unter Linux/UNIX zumindest) in Wirklichkeit korrekt <span class="clisting">open(const char *, int, ...)</span> lautet, kann je nach Situation das dritte Argument auch wegfallen.</p>
<p>Beim Modus gibt es mehrere Varianten, aber diese sind systemabhängig. Einer der drei Modi, die in Tabelle 16.11 aufgeführt sind, muss immer angegeben werden.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter"><p class="ptabunter"><strong>Tabelle 16.11    </strong>Bearbeitungsmodi für »open()«</p>
</caption>
<tr>
<td class="tabellenkopf"><span class="cfett">Modus</span>
</td>
<td class="tabellenkopf"><span class="cfett">Bedeutung</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">O_WRONLY</pre></div>
</td>
<td class="tabellentext">
<p>nur zum Schreiben öffnen</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">O_RDWR</pre></div>
</td>
<td class="tabellentext">
<p>zum Lesen und Schreiben öffnen</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">O_RDONLY</pre></div>
</td>
<td class="tabellentext">
<p>nur zum Lesen öffnen</p>
</td>
</tr>
</table><br><p>Dies sieht dann unter Linux/UNIX folgendermaßen aus:</p>
<div class="listing"><pre class="prettyprint">int fh;
if((fh = open("/home/programmname", O_RDONLY)) != -1)</pre></div>
<p>oder unter Windows/MS-DOS:</p>
<div class="listing"><pre class="prettyprint">if((fh = open("c:\\config.sys", O_RDONLY)) != -1)</pre></div>
<p>In den beiden Beispielen wird eine Datei nur zum Lesen geöffnet. Bei einem dieser drei genannten Modi können Sie mit dem bitweisen ODER-Zeichen (<span class="clisting">|</span>) weitere Aktionen verknüpfen. Dies sieht dann so aus:</p>
<div class="listing"><pre class="prettyprint">if((fh = open("c:\\test.sys", O_WRONLY|O_CREAT)) != -1)</pre></div>
<p>Hiermit wird eine Datei zum Schreiben geöffnet. Existiert diese Datei nicht, so wird sie erzeugt (<span class="clisting">O_CREAT</span>). Existiert diese Datei, so wird der zusätzliche Modus <span class="clisting">O_CREATE</span> ignoriert. Tabelle 16.12 zeigt die zusätzlichen Modi, die für Linux/UNIX und Windows/MS-DOS darüber hinaus zur Verfügung stehen.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter"><p class="ptabunter"><strong>Tabelle 16.12    </strong>Weitere Bearbeitungsmodi für »open()«</p>
</caption>
<tr>
<td class="tabellenkopf"><span class="cfett">Modus</span>
</td>
<td class="tabellenkopf"><span class="cfett">Bedeutung</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">O_CREAT</pre></div>
</td>
<td class="tabellentext">
<p>Falls die Datei nicht existiert, wird sie neu angelegt. Falls die Datei existiert, ist <span class="clisting">O_CREAT</span> ohne Wirkung.</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">O_APPEND</pre></div>
</td>
<td class="tabellentext">
<p>Datei öffnen zum Schreiben am Ende</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">O_EXCL</pre></div>
</td>
<td class="tabellentext">
<p><span class="clisting">O_EXCL</span> kombiniert mit <span class="clisting">O_CREAT</span> bedeutet, dass die Datei nicht geöffnet werden kann, wenn sie bereits existiert und <span class="clisting">open()</span> den Wert &#8211;1 zurückliefert (&#8211;1 == Fehler).</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">O_TRUNC</pre></div>
</td>
<td class="tabellentext">
<p>Eine Datei, die zum Schreiben geöffnet wird, wird geleert. Darauffolgendes Schreiben bewirkt erneutes Beschreiben der Datei von Anfang an. Die Attribute der Datei bleiben erhalten.</p>
</td>
</tr>
</table><br><p>Beispielsweise wird mit</p>
<div class="listing"><pre class="prettyprint">if((fh = open("/home/Name.txt", O_WRONLY | O_TRUNC)) != -1)</pre></div>
<p>erreicht, dass die Datei <span class="ckursiv">Name.txt</span> zum Schreiben geöffnet wird. Der Inhalt dieser Datei wird gelöscht, und sie kann neu beschrieben werden. Tabelle 16.13 listet weitere Modi auf, die nur für Linux/UNIX zur Verfügung stehen.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter"><p class="ptabunter"><strong>Tabelle 16.13    </strong>Bearbeitungsmodi nur für Linux/UNIX</p>
</caption>
<tr>
<td class="tabellenkopf"><span class="cfett">Modus</span>
</td>
<td class="tabellenkopf"><span class="cfett">Bedeutung</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">O_NOCTTY</pre></div>
</td>
<td class="tabellentext">
<p>Falls der Pfadname der Name eines Terminals ist, so sollte dieses nicht das neue Kontrollterminal des Prozesses werden, sofern der aktuelle Prozess kein Kontrollterminal besitzt.</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">O_NONBLOCK</pre></div>
</td>
<td class="tabellentext">
<p>Falls der Pfadname der Name eines FIFOs oder einer Gerätedatei ist, wird der Prozess beim Öffnen und bei nachfolgenden 
I/O-Operationen nicht blockiert. Dieses Flag zeigt seine Wirkung erst bei einer Pipe oder nichtblockierenden Sockets.</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">O_SYNC</pre></div>
</td>
<td class="tabellentext">
<p>Jeder Schreibvorgang auf das Medium wird direkt ausgeführt, und es wird gewartet, bis der Schreibvorgang komplett beendet wurde. Dieses Flag setzt den Pufferungsmechanismus außer Kraft. <span class="clisting">O_SYNC</span> wird nicht von POSIX.1 unterstützt, wohl aber von SVR4.</p>
</td>
</tr>
</table><br><p>Für Windows/MS-DOS gibt es die Extra-Modi, die in Tabelle 16.14 aufgelistet sind.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter"><p class="ptabunter"><strong>Tabelle 16.14    </strong>Bearbeitungsmodi nur für MS-DOS/Windows</p>
</caption>
<tr>
<td class="tabellenkopf"><span class="cfett">Modus</span>
</td>
<td class="tabellenkopf"><span class="cfett">Bedeutung</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">O_BINARY</pre></div>
</td>
<td class="tabellentext">
<p>Legt den Binärmodus der Datei fest.</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">O_TEXT</pre></div>
</td>
<td class="tabellentext">
<p>Legt den Textmodus der Datei fest.</p>
</td>
</tr>
</table><br><p>Jetzt folgen noch einige Modi, mit denen die Zugriffsrechte auf eine Datei erteilt werden können. Die Modi für Windows/MS-DOS sehen Sie in Tabelle 16.15.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter"><p class="ptabunter"><strong>Tabelle 16.15    </strong>Zugriffsrechte auf eine Datei erteilen (MS-DOS/Windows)</p>
</caption>
<tr>
<td class="tabellenkopf"><span class="cfett">Modus für Zugriffe</span>
</td>
<td class="tabellenkopf"><span class="cfett">Bedeutung</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">S_IWRITE</pre></div>
</td>
<td class="tabellentext">
<p>Schreiben erlaubt</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">S_IREAD</pre></div>
</td>
<td class="tabellentext">
<p>Lesen erlaubt</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">S_IREAD | SIWRITE</pre></div>
</td>
<td class="tabellentext">
<p>Lesen und Schreiben erlaubt</p>
</td>
</tr>
</table><br><p>Mit folgender Zeile wird z. B. eine Datei erzeugt, die nur gelesen werden darf:</p>
<div class="listing"><pre class="prettyprint">if((fh=open("new.xxx", O_CREAT , S_IREAD)) == -1)</pre></div>
<p>Wenn das Lesen und Schreiben erlaubt sein sollen, sieht dies so aus:</p>
<div class="listing"><pre class="prettyprint">if((fh=open("new.xxx",O_CREAT, S_IREAD|S_IWRITE)) == -1)</pre></div>
<p>Diese drei Zugriffsrechte für Windows/MS-DOS stehen in der Headerdatei     <span class="ckursiv">&lt;sys\stat.h&gt;</span>.</p>
<p>Für Linux/UNIX können Sie folgende Zugriffsrechte erteilen, die sich in der Headerdatei <span class="ckursiv">&lt;sys/stat.h&gt;</span> befinden. Tabelle 16.16 enthält die Modi für Zugriffsrechte unter Linux/UNIX.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter"><p class="ptabunter"><strong>Tabelle 16.16    </strong>Zugriffsrechte auf eine Datei erteilen (Linux/UNIX)</p>
</caption>
<tr>
<td class="tabellenkopf"><span class="cfett">Modus für Zugriffe</span>
</td>
<td class="tabellenkopf"><span class="cfett">Bedeutung</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">S_ISUID</pre></div>
</td>
<td class="tabellentext">
<p>Set-user-ID-Bit</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">S_ISGID</pre></div>
</td>
<td class="tabellentext">
<p>Set-group-ID-Bit</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">S_ISVTX</pre></div>
</td>
<td class="tabellentext">
<p>Sticky Bit (saved-text Bit)</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">S_IRUSR</pre></div>
</td>
<td class="tabellentext">
<p><span class="clisting">read</span> (<span class="clisting">user</span>; Leserecht für Eigentümer)</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">S_IWUSR</pre></div>
</td>
<td class="tabellentext">
<p><span class="clisting">write</span> (<span class="clisting">user</span>; Schreibrecht für Eigentümer)</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">S_IXUSR</pre></div>
</td>
<td class="tabellentext">
<p><span class="clisting">execute</span> (<span class="clisting">user</span>; Ausführungsrecht für Eigentümer)</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">S_IRWXU</pre></div>
</td>
<td class="tabellentext">
<p><span class="clisting">read</span>, <span class="clisting">write</span>, <span class="clisting">execute</span> (<span class="clisting">user</span>; Lese-, Schreib-, Ausführungsrecht für Eigentümer)</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">S_IRGRP</pre></div>
</td>
<td class="tabellentext">
<p><span class="clisting">read</span> (<span class="clisting">group</span>; Leserecht für Gruppe)</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">S_IWGRP</pre></div>
</td>
<td class="tabellentext">
<p><span class="clisting">write</span> (<span class="clisting">group</span>; Schreibrecht für Gruppe)</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">S_IXGRP</pre></div>
</td>
<td class="tabellentext">
<p><span class="clisting">execute</span> (<span class="clisting">group</span>; Ausführungsrecht für Gruppe)</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">S_IRWXG</pre></div>
</td>
<td class="tabellentext">
<p><span class="clisting">read</span>, <span class="clisting">write</span>, <span class="clisting">execute</span> (<span class="clisting">group</span>; Lese-, Schreib-, Ausführungsrecht für Eigentümer)</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">S_IROTH</pre></div>
</td>
<td class="tabellentext">
<p><span class="clisting">read</span> (<span class="clisting">other</span>; Leserecht für alle anderen Benutzer)</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">S_IWOTH</pre></div>
</td>
<td class="tabellentext">
<p><span class="clisting">write</span> (<span class="clisting">other</span>; Schreibrecht für alle anderen Benutzer)</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">S_IXOTH</pre></div>
</td>
<td class="tabellentext">
<p><span class="clisting">execute</span> (<span class="clisting">other</span>; Ausführungsrecht für alle anderen Benutzer)</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">S_IRWXO</pre></div>
</td>
<td class="tabellentext">
<p><span class="clisting">read</span>, <span class="clisting">write</span>, <span class="clisting">execute</span> (<span class="clisting">other</span>; Lese-, Schreib-, Ausführungsrecht für alle anderen Benutzer)</p>
</td>
</tr>
</table><br><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellenkopf"><span class="cfett">Hinweis</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p class="BStandard">Sofern Sie mit der oktalen Schreibweise der Rechtevergabe vertraut sind, können Sie natürlich diese als Alternative verwenden, beispielsweise so:<span class="clisting">
fd</span> <span class="clisting">=</span> <span class="clisting">open(</span> <span class="clisting">new_file,</span> <span class="clisting">O_WRONLY</span> <span class="clisting">|</span> <span class="clisting">O_EXCL</span> <span class="clisting">|</span> <span class="clisting">O_CREAT,</span> <span class="cfett">0644</span><span class="clisting">);</span></p>
</td>
</tr>
</table><br><p>Außerdem sollten Sie noch wissen, dass bei Verwendung des Flags <span class="clisting">O_CREAT</span> die Zugriffsrechte unter Linux/UNIX nicht unbedingt gewährt werden müssen, da die Einschränkungsmaske die Vergabe von Rechten verhindern kann (wird) &#8211; und somit die Rechte selbst. Aus diesem Grund wurde mithilfe der Funktion <span class="clisting">umask()</span> die Maske zur Wegnahme von Rechte-Bits auf 0 gesetzt, womit alle Zugriffsrechte in dieser Maske erlaubt werden.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellenkopf"><span class="cfett">Tipp</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p class="BStandard">Standardmäßig wird meistens die Einschränkungsmaske 022 vergeben. Es ist aber auch möglich, mit dem Shell-Built-in-Kommando <span class="clisting">umask</span> die eigene Einschränkungsmaske zu ändern. Innerhalb eines Listings z.  B. würde die neu gesetzte <span class="clisting">umask</span> von 0 nur während der Ausführung des Programms (und der Unterprozesse) gültig. Dazu kann man beispielsweise einen entsprechenden <span class="clisting">umask</span>-Aufruf in einer Startup-Datei wie .profile eintragen, sodass beim Start einer entsprechenden Shell die Einschränkungsmaske automatisch gesetzt wird.</p>
</td>
</tr>
</table><br><p>Im folgenden Listing soll eine Datei zum Lesen und Schreiben geöffnet werden. Existiert diese nicht, wird eine neue Datei erzeugt. Falls sie existiert, wird der Inhalt gelöscht und neu beschrieben. Hier sehen Sie den Quellcode, der portabel gehalten wurde:</p>
<div class="listing"><pre class="prettyprint">/* open1.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#ifdef __unix__
      #include &lt;unistd.h&gt;
#elif __MSDOS__ || __WIN32__ || _MSC_VER
      #include &lt;io.h&gt;
#endif

int main(void) {
   int fh;

   if((fh=open("adress.txt", O_RDWR|O_CREAT|O_TRUNC))==-1) {
      perror("Fehler bei open()");
      return EXIT_FAILURE;
   }
   close(fh);
   return EXIT_SUCCESS;
}</pre></div>
<p>Falls Sie jetzt noch die Zugriffsrechte auf diese Datei vergeben wollen, muss für Linux/UNIX die Headerdatei <span class="ckursiv">&lt;sys/stat.h&gt;</span> und für MS-DOS/Windows <span class="ckursiv">&lt;sys\stat.h&gt;</span> eingebunden werden (beachten Sie den Slash und Backslash). Soll beispielsweise der User unter Linux diese Datei nur lesen dürfen, so muss nur mithilfe des ODER-Operators der Modus <span class="clisting">S_IRUSR</span> hinzugefügt werden:</p>
<div class="listing"><pre class="prettyprint">// alle Zugriffsrechte der Einschränkungsmaske erlauben
umask(0);

open("adress.txt", O_RDWR|O_CREAT|O_TRUNC, S_IRUSR)) == -1)</pre></div>
<p>Ein weiteres Beispiel mit <span class="clisting">open()</span> ist z. B. das Aufrufen von Programmen aus der Kommandozeile:</p>
<div class="listing"><pre class="prettyprint">/* open2.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#ifdef __unix__
      #include &lt;unistd.h&gt;
      #include &lt;sys/stat.h&gt;
      #include &lt;sys/types.h&gt;
#elif __MSDOS__ || __WIN32__ || _MSC_VER
      #include &lt;io.h&gt;
      #include &lt;sys\stat.h&gt;
#endif

int main(int argc, char *argv[]) {
   int fh;

   if( (fh=open(*++argv,O_RDONLY)) == -1)
      perror(*argv);
   else
      close(fh);
   return EXIT_SUCCESS;
}</pre></div>
<p>In diesem Beispiel wird eine Datei zum Lesen geöffnet, deren Name als zweites Argument in der Kommandozeile angegeben wurde. Falls die Datei nicht existiert, wird eine entsprechende Fehlermeldung wie</p>
<div class="listing"><pre class="prettyprint">Programmname : No such File in Directory</pre></div>
<p>ausgegeben. Danach wird der File-Deskriptor wieder geschlossen. Falls die Datei, die eben aufgerufen wurde, nicht existiert, aber anschließend erzeugt werden soll, dann ist dies so möglich:</p>
<div class="listing"><pre class="prettyprint">/* open3.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#ifdef __unix__
      #include &lt;unistd.h&gt;
      #include &lt;sys/stat.h&gt;
      #include &lt;sys/types.h&gt;
#elif __MSDOS__ || __WIN32__ || _MSC_VER
      #include &lt;io.h&gt;
      #include &lt;sys\stat.h&gt;
#endif

int main(int argc,char *argv[]) {
   int fh;
   if(*++argv == NULL)
      return EXIT_FAILURE;  /* keine Argumente vorhanden */
   if( (fh = open(*argv, O_RDONLY)) == -1)
      if( (fh = open(*argv,O_RDWR|O_CREAT)) == -1)
         perror(*argv);
   close(fh);
   return EXIT_SUCCESS;
}</pre></div>
<p>Hiermit wird zuerst versucht, die Datei zu öffnen. Falls die Datei nicht existiert, wird sie gleich zum Lesen und Schreiben erzeugt.</p>
<p>Bei der Erläuterung der Low-Level-Datei-E/A-Funktionen konnten Sie schon erkennen, warum eher auf die höhere Ebene zurückgegriffen wird. Wer auf mehreren Systemen programmiert, kann schnell durcheinanderkommen. Was bei dem einen System gelingt, ist bei dem anderen nicht machbar. Andererseits ist es durchaus hilfreich, beim Erzeugen einer Datei die Zugriffsrechte von Beginn an festzulegen (das gilt speziell unter Linux/UNIX). Daraus ergibt sich, dass Low-Level-Datei-E/A-Funktionen vorwiegend zur Systemprogrammierung eingesetzt werden.</p>
<p>Vor allem für Linux/UNIX-Programmierer ist diese Art, eine Datei (auch Gerätedateien) zu öffnen, eine sehr wichtige Schnittstelle. Beispielsweise kann man hier mit folgendem einfachen Code-Konstrukt etwas auf dem Drucker ausgeben lassen:</p>
<div class="listing"><pre class="prettyprint">int fd;
// Drucker auf /dev/lp0 zum Schreiben öffnen
fd = open("/dev/lp0", O_WRONLY);
if(fd &gt;= 0)
   // drucken ...
   write(fd, buf, buf_size);
close(fd);</pre></div><a id="mj67da1cd8132864af50120ea4037c9cac" name="mj67da1cd8132864af50120ea4037c9cac"></a><a name="t32"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div><a name="t2t33"></a><h3 class="t3"><span class="cfett">16.26.2</span><span class="cfett"> Datei schließen &#8211; »close()«</span>  <a href="#t2t34"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t32"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p><span class="clisting">close()</span> dient dazu, eine Datei mit dem Deskriptor <span class="clisting">fh</span> zu schließen, die zuvor mit <span class="clisting">open()</span> oder <span class="clisting">create()</span> geöffnet bzw. erzeugt wurde. Denn auch mit der Funktion <span class="clisting">open()</span> kann nur eine bestimmte Anzahl von Dateien gleichzeitig geöffnet werden. Die Anzahl der maximal offenen Dateien ist in der Konstante <span class="clisting">OPEN_MAX</span> deklariert. Hier sehen Sie die Syntax zu <span class="clisting">close()</span>:</p>
<div class="listing"><pre class="prettyprint">int close(int fh);</pre></div>
<p>Der Rückgabewert der Funktion ist bei Fehler &#8211;1, ansonsten 0. Hierzu noch ein kurzes Listing:</p>
<div class="listing"><pre class="prettyprint">/* close.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#ifdef __unix__
      #include &lt;unistd.h&gt;
#elif __MSDOS__ || __WIN32__ || _MSC_VER
      #include &lt;io.h&gt;
#endif

int main(void) {
   int fh;

   if((fh=open("adressen.txt", O_RDONLY | O_CREAT)) == -1) {
      perror("Fehler bei open");
      return EXIT_FAILURE;
   }
   if((close(fh)) == -1)
      printf("Fehler beim Schliessen der Datei\n");
   else
      printf("Datei wurde ordentlich geschlossen\n");
   return EXIT_SUCCESS;
}</pre></div>
<p>Sie öffnen hier mit <span class="clisting">open()</span> eine Datei zum Lesen. Falls diese nicht existiert, wird eine neue erzeugt. Danach wird der Deskriptor wieder mit einer Überprüfung geschlossen, ob der Schließvorgang ordnungsgemäß verlief. Beim Programmende schließen sich die offenen Deskriptoren selbst.</p><a id="mjc13c6661f7e8039d407be6afe6d36f0f" name="mjc13c6661f7e8039d407be6afe6d36f0f"></a><a name="t33"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div><a name="t2t34"></a><h3 class="t3"><span class="cfett">16.26.3</span><span class="cfett"> Datei erzeugen &#8211; »creat()«</span>  <a href="#t2t35"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t33"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Außer mit <span class="clisting">open()</span> kann auch mit der Funktion <span class="clisting">creat()</span> eine neue Datei angelegt werden. Die Syntax von <span class="clisting">creat()</span> sieht bei Linux/UNIX so aus:</p>
<div class="listing"><pre class="prettyprint">#include &lt;fcntl.h&gt;
#inlcude &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;

int creat(const char *pfad, int modus);</pre></div>
<p>und unter Windows/MS-DOS so:</p>
<div class="listing"><pre class="prettyprint">#include &lt;fcntl.h&gt;
#inlcude &lt;io.h&gt;
#include &lt;sys\stat.h&gt;

int creat(const char *pfad, int modus);</pre></div>
<p><span class="clisting">creat()</span> arbeitet genauso wie die Funktion <span class="clisting">open()</span>. <span class="clisting">pfad</span> ist der Name der neu anzulegenden Datei mit dem Pfad. Mit <span class="clisting">modus</span> sind die Modi gemeint, die im Abschnitt zu <span class="clisting">open()</span> geschildert wurden. Existiert eine Datei bereits, wird diese geöffnet und geleert.</p>
<p>Mit der Funktion <span class="clisting">open()</span> und den Modi <span class="clisting">O_CREAT</span> und <span class="clisting">O_TRUNC</span> erreichen Sie dasselbe wie mit <span class="clisting">creat()</span>. Und somit ist die Funktion <span class="clisting">creat()</span> eigentlich völlig überflüssig und umständlich, da eine neu mit <span class="clisting">creat()</span> angelegte Datei nur beschrieben werden kann. Um diese Datei lesen zu können, muss sie zuerst mit <span class="clisting">close()</span> geschlossen werden, um sie anschließend mit <span class="clisting">open()</span> zum Lesen zu öffnen.</p>
<p><span class="clisting">creat()</span> wurde zu einer Zeit benötigt, als die Funktion <span class="clisting">open()</span> noch nicht die Angabe von <span class="clisting">O_CREAT</span> kannte. Jetzt bleibt die Funktion natürlich weiterhin bestehen, da sonst alte Programme, die zu dieser Zeit entwickelt wurden, ohne Änderung am Quellcode nicht mehr übersetzt werden können.</p><a id="mjcc7066e693d758cfc5fd93b9e47a84e4" name="mjcc7066e693d758cfc5fd93b9e47a84e4"></a><a name="t34"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div><a name="t2t35"></a><h3 class="t3"><span class="cfett">16.26.4</span><span class="cfett"> Schreiben und Lesen &#8211; »write()« und »read()«</span>  <a href="#t2t36"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t34"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Wir betrachten zuerst die Syntax der Funktion <span class="clisting">write ()</span>:</p>
<div class="listing"><pre class="prettyprint">#include &lt;unistd.h&gt; /* für UNIX/LINUX */
#include &lt;io.h&gt;     /* für MS-DOS     */

int write(int fh, const void *puffer, size_t bytezahl);</pre></div>
<p>Mit der Funktion <span class="clisting">write()</span> wird unformatiert in die Datei mit dem File-Deskriptor <span class="clisting">fh</span> geschrieben. Um den geeigneten File-Deskriptor zu erhalten, muss die Datei zuvor mit <span class="clisting">open()</span> oder <span class="clisting">create()</span> geöffnet werden. Dann schreibt <span class="clisting">write()</span> von der Datei mit dem <span class="clisting">fh-</span>File-Deskriptor <span class="clisting">bytezahl</span> Bytes in die Speicheradresse von <span class="clisting">puffer</span>. Dieser ist wieder ein typenloser <span class="clisting">void</span>-Zeiger und kann somit jeden beliebigen Datentyp annehmen. Bei einem Fehler liefert diese Funktion den Wert &#8211;1 zurück, ansonsten die Anzahl der erfolgreich geschriebenen Bytes. Hierzu ein einfaches Beispiel mit <span class="clisting">write()</span>:</p>
<div class="listing"><pre class="prettyprint">/* write1.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#ifdef __unix__
      #include &lt;unistd.h&gt;
#elif __MSDOS__ || __WIN32__ || _MSC_VER
      #include &lt;io.h&gt;
#endif

int main(void) {
   int fh;
   char puffer[100];

   strcpy(puffer,"Dieser Text steht in \"test.txt\"\n");

   if((fh=open("test.txt",O_RDWR|O_CREAT|O_TRUNC)) == -1) {
      perror(NULL);
      return EXIT_FAILURE;
    }

   if((write(fh, &amp;puffer, sizeof(puffer))) == -1) {
      perror("Fehler bei write");
      return EXIT_FAILURE;
   }
   printf("Erfolgreich in \"test.txt\" geschrieben\n");
   return EXIT_SUCCESS;
}</pre></div>
<p>Zuerst wird mit <span class="clisting">strcpy()</span> ein String in das Array <span class="clisting">puffer</span> kopiert. Danach wird mit <span class="clisting">open()</span> die Datei <span class="ckursiv">test.txt</span> geöffnet bzw. erzeugt. In den von <span class="clisting">open()</span> zurückgegebenen File-Deskriptor werden dann mit der Funktion <span class="clisting">write()</span> von der Adresse <span class="clisting">puffer</span> Bytes der Anzahl <span class="clisting">sizeof(puffer)</span> geschrieben.</p>
<p>Die Funktion <span class="clisting">write()</span> eignet sich genauso wie <span class="clisting">fwrite()</span> dazu, ganze Strukturen auf einmal zu schreiben, wie das folgende Listing demonstriert:</p>
<div class="listing"><pre class="prettyprint">/* write2.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#ifdef __linux__
      #include &lt;unistd.h&gt;
      #include &lt;sys/stat.h&gt;
      #include &lt;sys/types.h&gt;
#elif __MSDOS__ || __WIN32__ || _MSC_VER
      #include &lt;io.h&gt;
      #include &lt;sys\stat.h&gt;
#endif
#define MAXADRESSEN 10
#define MAX 30

struct kunde  {
   char name[MAX];
   char vorname[MAX];
   int kundenummer;
   char ort[MAX];
   char strasse[MAX];
   int hausnummer;
   int vorwahl;
   int telefonnr;
};

struct kunde k[MAXADRESSEN];
static int counter=0;

void neukunde(void) {
   int fh;

   if(counter==MAXADRESSEN)
      printf("Kein Speicherplatz mehr frei!!!\n");
   else {
      printf("Name...................: ");
      fgets(k[counter].name, MAX, stdin);
      printf("Vorname................: ");
      fgets(k[counter].vorname, MAX, stdin);
      k[counter].kundenummer=counter;
      printf("Ort....................: ");
      fgets(k[counter].ort, MAX, stdin);
      printf("Strasse................: ");
      fgets(k[counter].strasse, MAX, stdin);
      printf("Hausnummer.............: ");
      do {
         scanf("%d",&amp;k[counter].hausnummer);
      } while(getchar() != '\n');
      printf("Vorwahl................: ");
      do {
         scanf("%d",&amp;k[counter].vorwahl);
      } while(getchar() != '\n');
      printf("Telefonnummer..........: ");
      do {
         scanf("%d",&amp;k[counter].telefonnr);
      } while(getchar() != '\n');
      if((fh=creat("kunden.dat",S_IREAD|S_IWRITE)) == -1)
         printf("Konnte\"kunden.dat\" nicht öffnen\n");
      else if((write(fh,&amp;k,sizeof(k))) == -1)
         printf("Konnte nicht in \"kunden.dat\" schreiben\n");
      else
         counter++;
   }
}

int main(void) {
   int wahl;

   do {
      printf("\t1: Neuen Kunden eingeben\n\n");
      /* printf("\t2: Kunden ausgeben\n\n"); */
      printf("\t3: Programmende\n\n");
      printf("\tEingabe :&gt; ");
      do {
         scanf("%d",&amp;wahl);
      } while(getchar() != '\n');
      switch(wahl) {
         case 1  : neukunde(); break;
         /* case 2 : lese(); break; */
         case 3  : printf("bye\n"); break;
         default : printf("Falsche Eingabe!!!\n");
      }
   } while(wahl != 3);
   return EXIT_SUCCESS;
}</pre></div>
<p>Zuerst werden in der Funktion <span class="clisting">neukunde()</span> die Daten an die Struktur übergeben. Anschließend wird mit</p>
<div class="listing"><pre class="prettyprint">if((fh=creat("kunden.dat",S_IREAD|S_IWRITE)) == -1)</pre></div>
<p>eine Datei namens <span class="ckursiv">kunden.dat</span> zum Lesen und Schreiben erzeugt. Jetzt kann mit</p>
<div class="listing"><pre class="prettyprint">else if((write(fh,&amp;k,sizeof(k))) == -1)</pre></div>
<p>in diese Datei über den File-Deskriptor <span class="clisting">fh</span> von der Adresse <span class="clisting">struct kunde k</span> mit der Größe der Struktur (<span class="clisting">sizeof(k)</span>) geschrieben werden. Anschließend wird <span class="clisting">counter</span> inkrementiert. Ein wenig verwirrend können die <span class="clisting">if else</span>-Bedingungen sein. Aber bei Korrektheit werden alle drei ausgeführt, solange keine der Bedingungen &#8211;1 zurückliefert. Jetzt befindet sich im Verzeichnis, in dem das Programm ausgeführt wird, eine Datei namens <span class="ckursiv">kunden.dat</span>. Wird diese Datei mit einem Texteditor geöffnet, könnte man meinen, das Schreiben mit <span class="clisting">write()</span> hätte nicht geklappt. Aber wie ich bereits erwähnt habe, wird unformatiert in eine Datei geschrieben. Und dies lässt sich nun mal nicht mit einem Texteditor lesen.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellenkopf"><span class="cfett">Anmerkung</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p class="BStandard">Das Schreiben mit <span class="clisting">write()</span> wird über einen Puffercache durchgeführt, bevor wirklich auf die Festplatte, Diskette usw. geschrieben wird. Dieses <span class="ckursiv">Delayed Write</span> birgt bei einem Systemabsturz die Gefahr, dass im Cache befindliche Daten nicht physikalisch auf Festplatte oder Diskette geschrieben werden. In diesem Fall können Sie die Datei zum Schreiben im <span class="clisting">O_SYNC</span>-Modus öffnen. Dieser Modus wartet bei jedem physikalischen Schreibvorgang, bis dieser fertig ist, und liest dann erst wieder Daten ein. Der Modus hat leider den Nachteil, schrecklich langsam zu sein. Für Linux gibt es hier zwei Funktionen, <span class="clisting">sync()</span> und <span class="clisting">fsync()</span>, die in diesem Buch allerdings nicht behandelt werden. Linux-User lesen bitte entsprechende Manpages, falls Sie diese Funktionen benötigen.</p>
</td>
</tr>
</table><br><p>Jetzt folgt das Gegenstück zur Funktion <span class="clisting">write()</span>. Zuerst die Syntax:</p>
<div class="listing"><pre class="prettyprint">int read(int fh, const void *puffer, site_t bytezahl);</pre></div>
<p>Mit der Funktion <span class="clisting">read()</span> werden <span class="clisting">bytezahl</span> Bytes aus der Datei mit dem File-Deskriptor <span class="clisting">fh</span> gelesen. Die Daten werden an derAdresse von <span class="clisting">puffer</span> abgelegt. Zuvor muss natürlich die Datei mit <span class="clisting">open()</span> geöffnet werden. Auch hier liefert die Funktion bei einem Fehler &#8211;1, ansonsten, wenn alles richtig verlief, die Anzahl gelesener Bytes zurück. Hierzu sehen Sie ein Listing, das eine Datei kopiert:</p>
<div class="listing"><pre class="prettyprint">/* read1.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#ifdef __unix__
      #include &lt;unistd.h&gt;
      #include &lt;sys/stat.h&gt;
      #include &lt;sys/types.h&gt;
#elif __MSDOS__ || __WIN32__ || _MSC_VER
      #include &lt;io.h&gt;
      #include &lt;sys\stat.h&gt;
#endif
#define MAXBYTES 1024

int main(int argc, char *argv[]) {
   int in,out,count;
   char buffer[MAXBYTES];

   if(argc &lt; 3) {
      printf("Aufruf: programmname quelldatei zieldatei\n");
      return EXIT_FAILURE;
   }
   if( (in=open(*++argv ,O_RDONLY)) == -1)
      printf("Fehler open %s\n", (char *)argv);
   if( (out=open(*++argv, O_WRONLY | O_TRUNC | O_CREAT)) == -1)
      printf("Fehler open %s\n", (char *)argv);
   while( (count = read(in, buffer, MAXBYTES)) )
      write(out,buffer,count);
   close(in);
   close(out);
   return EXIT_SUCCESS;
}</pre></div>
<p>Damit wird die Datei, die als zweites Argument in der Kommandozeile angegeben wird, in die Datei kopiert, die als drittes Argument angegeben wird.</p>
<p>Jetzt soll das erste Programm aus dem vorigen Abschnitt zu <span class="clisting">write()</span> mit der Funktion <span class="clisting">read()</span> ergänzt werden:</p>
<div class="listing"><pre class="prettyprint">/* read2.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#ifdef __unix__
      #include &lt;unistd.h&gt;
#elif __MSDOS__ || __WIN32__ || _MSC_VER
      #include &lt;io.h&gt;
      #include &lt;sys\stat.h&gt;
#endif

int main(void) {
   int fh;

   char puffer[100];
   char pufferneu[100];

   strcpy(puffer,"Dieser Text steht in \"test.txt\"\n");

   if( (fh = open("test.txt",O_RDWR|O_CREAT|O_TRUNC)) == -1) {
      perror(NULL);
      return EXIT_FAILURE;
   }
   if((write(fh, &amp;puffer, sizeof(puffer))) == -1) {
      perror("Fehler bei write");
      return EXIT_FAILURE;
   }
   close(fh);

   if( (fh = open("test.txt",O_RDONLY)) == -1) {
      perror(NULL);
      return EXIT_FAILURE;
   }
   if( (read(fh, &amp;pufferneu, sizeof(pufferneu))) == -1) {
      perror("Fehler bei read");
      return EXIT_FAILURE;
   }
   printf("%s" ,pufferneu);
   close(fh);
   return EXIT_SUCCESS;
}</pre></div>
<p>Bis zur Funktion <span class="clisting">write()</span> ist das so weit nichts Neues für Sie. Mit <span class="clisting">read()</span> wird hier die Größe von <span class="clisting">sizeof(pufferneu)</span> Bytes mit dem File-Deskriptor <span class="clisting">fh</span> in die Adresse von <span class="clisting">pufferneu</span> gelegt. Das Programm dürfte keinem mehr Kopfzerbrechen bereiten.</p>
<p>Daher soll auch das zweite obige Listing mit der Funktion <span class="clisting">read()</span> bestückt werden. Schließlich wollen Sie die Daten, die geschrieben wurden, auch wieder lesen können:</p>
<div class="listing"><pre class="prettyprint">/* read3.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#ifdef __unix__
      #include &lt;unistd.h&gt;
      #include &lt;sys/stat.h&gt;
      #include &lt;sys/types.h&gt;
#elif __MSDOS__ || __WIN32__ || _MSC_VER
      #include &lt;io.h&gt;
      #include &lt;sys\stat.h&gt;
#endif
#define MAXADRESSEN 10
#define MAX 30

struct kunde  {
   char name[MAX];
   char vorname[MAX];
   int kundenummer;
   char ort[MAX];
   char strasse[MAX];
   int hausnummer;
   int vorwahl;
   int telefonnr;
};

struct kunde k[MAXADRESSEN];
static int counter=0;

void neukunde(void) {
   int fh;

   if(counter==MAXADRESSEN)
      printf("Kein Speicherplatz mehr frei!!!\n");
   else {
      printf("Name...................: ");
      fgets(k[counter].name, MAX, stdin);
      printf("Vorname................: ");
      fgets(k[counter].vorname, MAX, stdin);
      k[counter].kundenummer=counter;
      printf("Ort....................: ");
      fgets(k[counter].ort, MAX, stdin);
      printf("Strasse................: ");
      fgets(k[counter].strasse, MAX, stdin);
      printf("Hausnummer.............: ");
      do {
         scanf("%d",&amp;k[counter].hausnummer);
      } while(getchar() != '\n');
      printf("Vorwahl................: ");
      do {
         scanf("%d",&amp;k[counter].vorwahl);
      } while(getchar() != '\n');
      printf("Telefonnummer..........: ");
      do {
         scanf("%d",&amp;k[counter].telefonnr);
      } while(getchar() != '\n');

      if((fh=open("kunden.dat",O_CREAT|O_RDWR)) == -1)
         printf("Konnte\"kunden.dat\" nicht öffnen\n");
      else if((write(fh,&amp;k,sizeof(k))) == -1)
           printf("Konnte nicht in \"kunden.dat\" schreiben\n");
      else
         counter++;
   }
}

void lese(void) {
   int fh;
   int num;

   printf("Bitte geben Sie die Kundennummer ein : ");
   scanf("%d",&amp;num);

   if( (fh = open("kunden.dat",O_RDONLY)) == -1) {
      perror("Kann Kundendatei nicht öffnen");
      exit(EXIT_FAILURE);
   }
   read(fh,&amp;k,sizeof(k));
   printf("\n\n");
   printf("Name..........%s",k[num].name);
   printf("Vorname.......%s",k[num].vorname);
   printf("Kundennummer..%d\n",k[num].kundenummer);
   printf("Wohnort.......%s",k[num].ort);
   printf("Strasse.......%s",k[num].strasse);
   printf("Hausnummer....%d\n",k[num].hausnummer);
   printf("Vorwahl.......%d\n",k[num].vorwahl);
   printf("Telefonnum....%d\n",k[num].telefonnr);
}

int main(void) {
   int wahl;

   do {
      printf("\t1: Neuen Kunden eingeben\n\n");
      printf("\t2: Kunden ausgeben\n\n");
      printf("\t3: Programmende\n\n");
      printf("\tEingabe :&gt; ");
      do {
         scanf("%d",&amp;wahl);
      }while(getchar() != '\n');
      switch(wahl) {
         case 1 : neukunde(); break;
         case 2 : lese(); break;
         case 3 : printf("bye\n"); break;
         default: printf("Falsche Eingabe!!!\n");
      }
   } while(wahl != 3);
   return EXIT_SUCCESS;
}</pre></div>
<p>Das Datenprogramm ist wieder um eine Funktion reicher geworden, nämlich um <span class="clisting">lese()</span>. Bei dieser wird mit</p>
<div class="listing"><pre class="prettyprint">if((fh=open("kunden.dat", O_RDONLY)) == -1)</pre></div>
<p>die Kundendatei zum Lesen geöffnet und mit</p>
<div class="listing"><pre class="prettyprint">read(fh,&amp;k,sizeof(k));</pre></div>
<p>ausgelesen sowie anschließend auf dem Bildschirm ausgegeben.</p>
<p>Ein paar Zeilen noch zum File-Deskriptor. Die folgende Anwendung des File-Deskriptors ist bekannt:</p>
<div class="listing"><pre class="prettyprint">write(fh, &amp;puffer, sizeof(puffer));
read(fh, &amp;puffer, sizeof(puffer));</pre></div>
<p>Aber statt des File-Deskriptors <span class="clisting">fh</span> können logischerweise auch Ganzzahlen verwendet werden. Die in Tabelle 16.17 genannten Ziffern sind allerdings fest belegt, da sie vordefinierte Deskriptoren sind.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter"><p class="ptabunter"><strong>Tabelle 16.17    </strong>Besetzte Werte für Deskriptoren</p>
</caption>
<tr>
<td class="tabellenkopf"><span class="cfett">Dezimalzahl</span>
</td>
<td class="tabellenkopf"><span class="cfett">Bedeutung</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p>0</p>
</td>
<td class="tabellentext">
<p>Standardeingabe (<span class="clisting">stdin</span>)</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p>1</p>
</td>
<td class="tabellentext">
<p>Standardausgabe (<span class="clisting">stdout</span>)</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p>2</p>
</td>
<td class="tabellentext">
<p>Standardfehlerausgabe (<span class="clisting">stderr</span>)</p>
</td>
</tr>
</table><br><p>Ein Listing dazu:</p>
<div class="listing"><pre class="prettyprint">/* deskriptor_nr1.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#ifdef __unix__
     #include &lt;unistd.h&gt;
#elif __MSDOS__ || __WIN32__ || _MSC_VER
     #include &lt;io.h&gt;
#endif

int main(void) {
   char puffer[100];
   read(0, &amp;puffer, sizeof(puffer));
   printf("%s",puffer);
   return EXIT_SUCCESS;
}</pre></div>
<p>Mit <span class="clisting">read(0, &amp;puffer, sizeof(puffer))</span> wird aus der Standardeingabe (<span class="clisting">stdin</span>) in die Adresse des Puffers gelesen, also von der Tastatur. Anhand der Ausgabe können Sie auch die Eigenheiten der niedrigeren Ebene erkennen. Hier wird nicht automatisch ein Stringende-Zeichen angehängt, darum müssen Sie sich selbst kümmern. Dasselbe kann auch mit <span class="clisting">write()</span> auf dem Bildschirm vorgenommen werden:</p>
<div class="listing"><pre class="prettyprint">/* deskriptor_nr2.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#ifdef __unix__
     #include &lt;unistd.h&gt;
#elif __MSDOS__ || __WIN32__ || _MSC_VER
     #include &lt;io.h&gt;
#endif

int main(void) {
   char puffer[] = "Ich werde im Low-Level-I/O ausgegeben";
   write(1, &amp;puffer, sizeof(puffer));
   return EXIT_SUCCESS;
}</pre></div>
<p>Da der File-Deskriptor manchmal so verwendet wird, sollte dies hier nicht unerwähnt bleiben.</p><a id="mj4bb8f95e72dd7e438479e91bb8c02c1e" name="mj4bb8f95e72dd7e438479e91bb8c02c1e"></a><a name="t35"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div><a name="t2t36"></a><h3 class="t3"><span class="cfett">16.26.5</span><span class="cfett"> File-Deskriptor positionieren &#8211; »lseek()«</span>  <a href="#t2t37"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t35"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p><span class="clisting">lseek()</span> ist dieselbe Funktion, die bei der höheren Ebene <span class="clisting">fseek()</span> hieß, und dient zum Verschieben des File-Deskriptors in der geöffneten Datei. Die Syntax von <span class="clisting">lseek()</span> lautet:</p>
<div class="listing"><pre class="prettyprint">#inlcude &lt;unistd.h&gt;      /* für UNIX */
#include &lt;sys/types.h&gt;   /* für UNIX */
#inlcude &lt;io.h&gt;          /* für MS-DOS/WIN */

long lseek(int fh, long offset, int wie);</pre></div>
<p>Die Datei, in der der File-Deskriptor verschoben werden soll, wird mit dem File-Deskriptor <span class="clisting">fh</span> angegeben, der natürlich zuvor mit <span class="clisting">open()</span> geöffnet bzw. erzeugt wurde. Um wie viele Bytes der File-Deskriptor von der Position <span class="clisting">wie</span> verschoben werden soll, wird mit <span class="clisting">offset</span> angegeben. Die Angaben von <span class="clisting">wie</span> sind dieselben wie schon bei <span class="clisting">fseek()</span>. Tabelle 16.18 zeigt, welche Möglichkeiten zur Verfügung stehen.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter"><p class="ptabunter"><strong>Tabelle 16.18    </strong>Bezugspunkt für die Positionierung (gleich wie bei »fseek«)</p>
</caption>
<tr>
<td class="tabellenkopf"><span class="cfett">wie-Angabe</span>
</td>
<td class="tabellenkopf"><span class="cfett">Beschreibung</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">SEEK_SET</span> oder 0</p>
</td>
<td class="tabellentext">
<p>Schreib/Lese-Deskriptor vom Dateianfang um <span class="clisting">offset</span> Bytes versetzen</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">SEEK_CUR</span> oder 1</p>
</td>
<td class="tabellentext">
<p>Schreib/Lese-Deskriptor von der aktuellen Position um <span class="clisting">offset</span> Bytes versetzen</p>
</td>
</tr>
<tr>
<td class="tabellentext">
<p><span class="clisting">SEEK_END</span> oder 2</p>
</td>
<td class="tabellentext">
<p>Schreib/Lese-Deskriptor vom Dateiende um <span class="clisting">offset</span> Bytes versetzen</p>
</td>
</tr>
</table><br><p>Als Rückgabewert gibt diese Funktion den Wert der aktuellen Position des File-Deskriptors zurück:</p>
<div class="listing"><pre class="prettyprint">long aktuelle_position;
aktuelle_position = lseek(fh, 0L, SEEK_CUR);</pre></div>
<p>Bei einem Fehler gibt diese Funktion &#8211;1 zurück. <span class="clisting">lseek()</span> sollte allerdings nicht auf kleiner als 0 geprüft werden, sondern auf &#8211;1, da es durchaus sein kann, dass es Gerätedateien gibt, die einen negativen Wert zurückliefern. Weitere Möglichkeiten von <span class="clisting">lseek()</span> sind:</p>
<p>Deskriptor auf den Dateianfang setzen:</p>
<div class="listing"><pre class="prettyprint">lseek(fh, 0L, SEEK_SET);</pre></div>
<p>Deskriptor um 100 Bytes von der aktuellen Position nach vorn versetzen:</p>
<div class="listing"><pre class="prettyprint">lseek(fh, 100L, SEEK_CUR);</pre></div>
<p>Deskriptor um 10 Bytes von der aktuellen Position zurücksetzen:</p>
<div class="listing"><pre class="prettyprint">lseek(fh, -10L, SEEK_CUR);</pre></div>
<p>Deskriptor auf das letzte Byte setzen (nicht <span class="clisting">EOF</span>):</p>
<div class="listing"><pre class="prettyprint">lseek(fh, -1L, SEEK_END);</pre></div>
<p>Ein Beispiel zu <span class="clisting">lseek()</span> kann ich mir sparen, da diese Funktion genauso eingesetzt wird wie <span class="clisting">fseek()</span>; nur dass anstatt eines Streams hierbei ein File-Deskriptor verwendet wird.</p><a id="mj32b392fdf813e7ba5f00d33a95179eac" name="mj32b392fdf813e7ba5f00d33a95179eac"></a><a name="t36"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div><a name="t2t37"></a><h3 class="t3"><span class="cfett">16.26.6</span><span class="cfett"> File-Deskriptor von einem Stream &#8211; »fileno()«</span>  <a href="#t2t38"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t36"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Manchmal benötigen Sie von einem offenen Stream den File-Deskriptor. Die Syntax dieser Funktion lautet:</p>
<div class="listing"><pre class="prettyprint">int fileno(FILE *fz);</pre></div>
<p><span class="clisting">fileno()</span> ist erforderlich, falls eine Datei mit <span class="clisting">fopen()</span> geöffnet wurde, um den Stream für Funktionen einzusetzen, die einen File-Deskriptor benötigen (z. B. Funktionen wie <span class="clisting">dup()</span>, <span class="clisting">dup2()</span> oder <span class="clisting">fcntl()</span>). Hier sehen Sie ein Listing dazu:</p>
<div class="listing"><pre class="prettyprint">/* fileno.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#ifdef __unix__
    #include &lt;unistd.h&gt;
#else
    #include &lt;io.h&gt;
#endif

int main(void) {
   FILE *fz;
   int fd,fd2;
   char datei[255];

   printf("File-Deskriptoren zu stdin, stdout und stderr : ");
   printf("%d, %d und %d\n",
      fileno(stdin),fileno(stdout),fileno(stderr));
   printf("Welche Datei wollen Sie öffnen : ");
   scanf("%s",datei);

   fz=fopen(datei, "r");
   if(!fz) {
      perror(NULL);
      return EXIT_FAILURE;
   }
   fd = fileno(fz);
   printf("File-Deskriptor zur Datei %s lautet %d\n",datei,fd);
   fd2=dup(fd);
   printf("File-Deskriptor, der kopiert wurde, lautet %d\n",fd2);
   return EXIT_SUCCESS;
}</pre></div>
<p>Zu Beginn des Programms werden erst die File-Deskriptoren zu <span class="clisting">stdin</span>, <span class="clisting">stdout</span> und <span class="clisting">stderr</span> ausgegeben, diese sollten immer 0, 1 und 2 sein. Anschließend wird der File-Deskriptor in einer von Ihnen geöffneten Datei ausgegeben. Dieser File-Deskriptor wird jetzt mit der Funktion <span class="clisting">dup()</span> dupliziert und ebenfalls auf dem Bildschirm ausgegeben.</p><a id="mj75c334204d8e6c4dd9bf1c6fd20669f9" name="mj75c334204d8e6c4dd9bf1c6fd20669f9"></a><a name="t37"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div><a name="t2t38"></a><h3 class="t3"><span class="cfett">16.26.7</span><span class="cfett"> Stream von File-Deskriptor &#8211; »fdopen()«</span>  <img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"><a href="#t2t37"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Mit der Funktion <span class="clisting">fdopen()</span> erhalten Sie aus einem File-Deskriptor einen <span class="clisting">FILE</span>-Zeiger:</p>
<div class="listing"><pre class="prettyprint">#include &lt;stdio.h&gt;

FILE *fdopen(int fd, const char *modus);</pre></div>
<p><span class="clisting">fdopen()</span> ist das Gegenstück zu <span class="clisting">fileno()</span>. Als <span class="clisting">modus</span>, wie die Datei geöffnet wird, können dieselben Modi wie bei der Funktion <span class="clisting">open()</span> genutzt werden.</p>
<p><span class="clisting">fdopen()</span> wird oft auf File-Deskriptoren angewandt, die von Funktionen zurückgegeben werden, die Pipes oder Kommunikationskanäle in Netzwerken einrichten. Das kommt daher, weil einige Funktionen (<span class="clisting">open()</span>, <span class="clisting">dup()</span>, <span class="clisting">dup2()</span>, <span class="clisting">fcntl()</span>, <span class="clisting">pipe(), ...</span>) in Netzwerken nichts mit Streams anfangen können und File-Deskriptoren benötigen. Um aber wieder aus Deskriptoren einen Stream (<span class="clisting">FILE</span>-Zeiger) zu erzeugen, ist die Funktion <span class="clisting">fdopen()</span> erforderlich. Hierzu ein kurzes Beispiel:</p>
<div class="listing"><pre class="prettyprint">/* fdopen.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#ifdef __linux__
   #include &lt;unistd.h&gt;
#else
   #include &lt;io.h&gt;
#endif

int main(void) {
   FILE *fz, *fz2;
   int fd,fd2;
   char datei[255];

   printf("Welche Datei wollen Sie erzeugen: ");
   scanf("%s",datei);

   fz=fopen(datei, "w+");
   if(!fz)
      perror(NULL);
   fd = fileno(fz);
   printf("File-Deskriptor zur Datei %s lautet %d\n",datei,fd);

   fd2=dup(fd);


   printf("Der File-Deskriptor, der kopiert wurde %d\n\n",fd2);

   printf("Wir wollen einen STREAM  oeffnen....\n");
   fz2 = fdopen(fd2, "w");
     if(!fz2)
        perror(NULL);

   fprintf(fz,"Dieser Text steht in %s\n",datei);
   fprintf(fz2,"Dieser Text steht auch in %s\n",datei);
   fprintf(stdout,"Es wurde etwas in die "
                  "Datei %s geschrieben",datei);
   return EXIT_SUCCESS;
}</pre></div>
<p>Die beiden Funktionen <span class="clisting">fileno()</span> und <span class="clisting">fdopen()</span> werden vorwiegend in der Netzwerkprogrammierung eingesetzt.</p>
<p> </p><br><hr><a name="kommentar"></a><h3>Ihr Kommentar</h3>
                       Wie hat Ihnen das &lt;openbook&gt; gefallen? Wir freuen uns immer über Ihre freundlichen und kritischen Rückmeldungen.
                       <!--<form action="http://www.galileo-press.de/feedback/openbook" method="post" style="text-align: center; margin-top: 10px;"><input type="hidden" name="openbookurl" value="http://openbook.galileocomputing.de/c_von_a_bis_z/016_c_ein_ausgabe_funktionen_026.htm"><input type="hidden" name="buchtitel" value="C von A bis Z"><input type="hidden" name="Kapitel" value="16.26 Low-Level-Datei-I/O-Funktionen (nicht ANSI C)"><table border="0">
<tr>
<td><label for="name">Name</label><br></td>
<td><input type="text" name="name" id="name" size="40"><br></td>
</tr>
<tr>
<td><label for="email">E-Mail</label><br></td>
<td><input type="text" name="email" id="email" size="40"><br></td>
</tr>
<tr>
<td valign="top"><label for="comment">Ihr Kommentar</label><br></td>
<td><textarea name="comment" id="comment" rows="10" cols="40"></textarea><br></td>
</tr>
<tr>
<td>
</td>
<td><input type="submit" value="Kommentar absenden"></td>
</tr>
</table>
</form>--><a href="https://www.rheinwerk-verlag.de/feedback/produkt/2132/">>> Zum Feedback-Formular</a>
</div></td>
</tr>
</table></td>
</tr>
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a href="016_c_ein_ausgabe_funktionen_025.html" class="navnav"> &lt;&lt;   zurück</a></td>
<td width="49%"><div align="center"><a class="navnav" href="#">&lt;top&gt;</a></div></td>
<td align="right" width="25%"><div align="right"><a href="017_c_dateien_verzeichnisse_001.html" class="navnav">vor   &gt;&gt; </a></div></td>
</tr>
</table></td>
</tr>
</table>
</div></td>
<td width="10" valign="top">&nbsp;&nbsp;</td>
<td width="160" valign="top">
<table border="0" cellpadding="0" cellspacing="0" width="160">
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="tbl2" height="20" colspan="2">
&nbsp;<a href="https://www.rheinwerk-verlag.de/?GPP=opc3" class="nav">
<strong>Zum Katalog</strong></a>
</td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2">
<img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td><a href="https://www.rheinwerk-verlag.de/c-von-a-bis-z_2132/?GPP=opc3">
	<img src="common/1411.gif" width="117" height="167" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C von A bis Z" title="Zum Katalog: C von A bis Z">
<br /><br /><strong>&nbsp;C von A bis Z</strong><br /><img src="common/pfeil_rechts5.gif" border="0" alt="">Jetzt&nbsp;bestellen</a><br /><br />
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="tbl2" height="20" colspan="2"><a href="#kommentar" class="nav"><strong>&nbsp;Ihre Meinung?</strong></a>
</td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td>Wie hat Ihnen das &lt;openbook&gt; gefallen?<br /><a href="#kommentar"><img src="common/pfeil_rechts5.gif" border="0" alt="">Ihre Meinung</a>
<br /><br /></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="tbl2" height="20" colspan="2">&nbsp;<a href="https://www.rheinwerk-verlag.de/?GPP=opc3" class="nav"><strong>Buchtipps</strong></a></td>
</tr>
<tr> 
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="https://www.rheinwerk-verlag.de/cc_3536/?GPP=opc3">
<img src="common/2757.gif" width="69" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C/C++" title="Zum Katalog: C/C++"><br /><br /><br /><br /><br /><br /><br />&nbsp;C/C++</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="https://www.rheinwerk-verlag.de/einstieg-in-c_3557/?GPP=opc3">
<img src="common/2793.gif" width="74" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Einstieg in C" title="Zum Katalog: Einstieg in C"><br /><br /><br /><br /><br /><br /><br />&nbsp;Einstieg in C</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="https://www.rheinwerk-verlag.de/schrodinger-programmiert-c_2853/?GPP=opc3">
<img src="common/1756.gif" width="85" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Schrödinger programmiert C++" title="Zum Katalog: Schrödinger programmiert C++"><br /><br /><br /><br /><br /><br /><br />&nbsp;Schrödinger<br />&nbsp;programmiert C++</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="https://www.rheinwerk-verlag.de/c_3278/?GPP=opc3">
<img src="common/2021.gif" width="69" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C++ Handbuch" title="Zum Katalog: C++ Handbuch"><br /><br /><br /><br /><br /><br /><br />&nbsp;C++ Handbuch</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="https://www.rheinwerk-verlag.de/it-handbuch-fur-fachinformatiker_3329/?GPP=opc3">
<img src="common/2234.gif" width="78" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: IT-Handbuch für Fachinformatiker" title="Zum Katalog: IT-Handbuch für Fachinformatiker"><br /><br /><br /><br /><br /><br /><br />&nbsp;IT-Handbuch für<br />&nbsp;Fachinformatiker</a><br /><br /></td>
</tr>
</table></td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="tbl2" height="20" colspan="2"><strong>&nbsp;Shopping</strong></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td><b>Versandkostenfrei</b> bestellen in Deutschland und &Ouml;sterreich<br /><a href="https://www.rheinwerk-verlag.de/hilfe/bestellung_6?GPP=opc3"><img src="common/pfeil_rechts5.gif" border="0" alt="Info">Info</a><br /><br /></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table><br><br><hr width="70%" align="center">
<div align="center">
<p class="standard"><strong>Copyright © Rheinwerk Verlag GmbH 2009</strong><br>
        Für Ihren privaten Gebrauch dürfen Sie die Online-Version natürlich ausdrucken.
        Ansonsten unterliegt das &lt;openbook&gt; denselben Bestimmungen, wie die
        gebundene Ausgabe: Das Werk einschließlich aller seiner Teile ist urheberrechtlich
        geschützt. Alle Rechte vorbehalten einschließlich der Vervielfältigung, Übersetzung,
        Mikroverfilmung sowie Einspeicherung und Verarbeitung in elektronischen Systemen.</p><br><a href="https://www.rheinwerk-verlag.de/">[Rheinwerk Computing]</a><br><br>
      Rheinwerk Verlag GmbH, Rheinwerkallee 4, 53227 Bonn, Tel.: 0228.42150.0, Fax 0228.42150.77, <a href="mailto:service@rheinwerk-verlag.de">service@rheinwerk-verlag.de</a></div><br><br></body>

<!-- Mirrored from openbook.rheinwerk-verlag.de/c_von_a_bis_z/016_c_ein_ausgabe_funktionen_026.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 23 Jun 2017 19:48:00 GMT -->
</html>
