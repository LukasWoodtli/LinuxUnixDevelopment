<html>

<!-- Mirrored from openbook.rheinwerk-verlag.de/c_von_a_bis_z/020_c_headerdateien_004.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 23 Jun 2017 19:48:04 GMT -->
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Rheinwerk Computing :: C von A bis Z &ndash; 20.4 &lt;stdlib.h&gt;</title>
<meta name="title" content="Rheinwerk Computing :: C von A bis Z - 20.4 <stdlib.h>">
<meta name="author" content="J&uuml;rgen Wolf ">
<meta name="publisher" content="Rheinwerk Verlag GmbH 2009">
<meta name="copyright" content="Rheinwerk Verlag GmbH 2009">
<meta name="Description" content="C von A bis Z - Das umfassende Handbuch &ndash; 20.4 <stdlib.h>">
<meta name="audience" content="Alle">
<meta name="robots" content="INDEX,FOLLOW">
<meta http-equiv="content-language" content="de">
<link rel="stylesheet" type="text/css" href="common/rw_open.css">
<link rel="prev" href="020_c_headerdateien_003.html">
<link rel="next" href="020_c_headerdateien_005.html"><script type="text/javascript"><!--
    function OpenWin(url,name,height,width)
    {
      var InfoWin = window.open(url,name,"directories=0,height="+height+",width=" + width + ",hotkeys=0,location=0,menubar=0,resizable=1,screenX=150,screenY=10,left=150,top=10,scrollbars=1,status=1,titlebar=0,toolbar=0");
      InfoWin.focus();
    }
    //--></script><link href="common/prettify.css" type="text/css" rel="stylesheet"><script type="text/javascript" src="common/prettify.js"></script></head>
<body vlink="#000099" link="#000099" alink="#000099" onload="prettyPrint()">
<table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#00549d">
<tr>
<td height="74" valign="bottom" colspan="2"><a href="https://www.rheinwerk-verlag.de/katalog/openbook?GPP=opc3"><img src="common/rw_openbook.gif" width="200" height="56" border="0" alt="Rheinwerk Computing < openbook >" title="Rheinwerk Computing < openbook >"></a></td>
<td width="80" height="74"><a href="https://www.rheinwerk-verlag.de/?GPP=opc3"><img src="common/rw_computing.gif" border="0" alt="Rheinwerk Computing - Professionelle Bücher. Auch für Einsteiger." title="Rheinwerk Computing - Professionelle Bücher. Auch für Einsteiger."></a></td>
</tr>
</table>
<div align="right"><a href="https://www.rheinwerk-verlag.de/?GPP=opc3" class="navnav">Professionelle Bücher. Auch für Einsteiger.</a></div><br><table class="tbl" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="190" valign="top">
<table class="tbl1" border="0" cellpadding="3" cellspacing="0" width="190" align="left">
<tr>
<td class="tbl2"><a class="nav" href="index-2.html#_top">Inhaltsverzeichnis</a></td>
</tr>
<tr>
<td><a class="navnav" href="000_c_vorwort_001.html#mj764cb3fd439d3b95d1843e7c7d17f235">Vorwort</a></td>
</tr>
<tr>
<td><a class="navnav" href="000_c_vorwort_gutachter_001.html#mj3d41cb339c9b2fc1d6e99cdaa93c3860">Vorwort des Gutachters</a></td>
</tr>
<tr>
<td><a class="navnav" href="001_c_einstieg_in_c_001.html#mja24d93ff97bb42dbebf4689160c45195">1 Einstieg in C</a></td>
</tr>
<tr>
<td><a class="navnav" href="002_c_das_erste_programm_001.html#mj2604a667cc98d3fa2178751273346b91">2 Das erste Programm</a></td>
</tr>
<tr>
<td><a class="navnav" href="003_c_grundlagen_001.html#mj7ac54ba315b94149806c1de3fc89ee7f">3 Grundlagen</a></td>
</tr>
<tr>
<td><a class="navnav" href="004_c_ein_ausgabe_001.html#mj20c131820fbfb1497afd796ee443599e">4 Formatierte Ein-/Ausgabe mit »scanf()« und »printf()«</a></td>
</tr>
<tr>
<td><a class="navnav" href="005_c_basisdatentypen_001.html#mjeda2957449ddc812dad62b400fe57752">5 Basisdatentypen</a></td>
</tr>
<tr>
<td><a class="navnav" href="006_c_operatoren_001.html#mjab3693b096d581607801a36ce88905fc">6 Operatoren</a></td>
</tr>
<tr>
<td><a class="navnav" href="007_c_typumwandlung_001.html#mj5c5e497ac2ab4367fe9df0ffd218cfca">7 Typumwandlung</a></td>
</tr>
<tr>
<td><a class="navnav" href="008_c_kontrollstrukturen_001.html#mjc7bf6f584a2fe20b4c5f6b16ba15d57d">8 Kontrollstrukturen</a></td>
</tr>
<tr>
<td><a class="navnav" href="009_c_funktionen_001.html#mj7893101be51aa469fe52334038acd465">9 Funktionen</a></td>
</tr>
<tr>
<td><a class="navnav" href="010_c_praeprozessor_001.html#mjacdd200a20163a4d3fa418b6cb95763e">10 Präprozessor-Direktiven</a></td>
</tr>
<tr>
<td><a class="navnav" href="011_c_arrays_001.html#mje29de26c54a3884f7316cbbb2a073ad8">11 Arrays</a></td>
</tr>
<tr>
<td><a class="navnav" href="012_c_zeiger_001.html#mjee28a882ef9125d2c4cc49121b2c65c1">12 Zeiger (Pointer)</a></td>
</tr>
<tr>
<td><a class="navnav" href="013_c_kommandozeilenargumente_001.html#mjf6a9e42fa3bc25b2b1e06270e7bf8f68">13 Kommandozeilenargumente</a></td>
</tr>
<tr>
<td><a class="navnav" href="014_c_dyn_speicherverwaltung_001.html#mj8d062301d2449b13710f1484d499cd9b">14 Dynamische Speicherverwaltung</a></td>
</tr>
<tr>
<td><a class="navnav" href="015_c_strukturen_001.html#mj5e146ba18168113a5c645cd2d07c4ec8">15 Strukturen</a></td>
</tr>
<tr>
<td><a class="navnav" href="016_c_ein_ausgabe_funktionen_001.html#mj136f9ac6b5b7c440aafe5010411ef011">16 Ein-/Ausgabe-Funktionen</a></td>
</tr>
<tr>
<td><a class="navnav" href="017_c_dateien_verzeichnisse_001.html#mj9f81aea722a9edb8d0080df81eb9402c">17 Attribute von Dateien und das Arbeiten mit Verzeichnissen (nicht ANSI C)</a></td>
</tr>
<tr>
<td><a class="navnav" href="018_c_stdarg_h_001.html#mj9d64febdc46a1375e5c4498b17154e30">18 Arbeiten mit variabel langen Argumentlisten &#8211; &lt;stdarg.h&gt;</a></td>
</tr>
<tr>
<td><a class="navnav" href="019_c_zeitroutinen_001.html#mj0a8102e96a1297bd767ac7274e069f0f">19 Zeitroutinen</a></td>
</tr>
<tr>
<td><a class="navh" href="##mjf3caede8ebd504dc6b7454b297c251e8">20 Weitere Headerdateien und ihre Funktionen (ANSI C)</a></td>
</tr>
<tr>
<td><a class="navnav" href="021_c_dyn_datenstrukturen_001.html#mja75ba2f4ab8f95e9e321d195c1e26d76">21 Dynamische Datenstrukturen</a></td>
</tr>
<tr>
<td><a class="navnav" href="022_c_algorithmen_001.html#mj07afe6f332eab2e8168da2f69f7b31c4">22 Algorithmen</a></td>
</tr>
<tr>
<td><a class="navnav" href="023_c_cgi_001.html#mj6c4219b4e615fa24deaa57d5c3d04db8">23 CGI mit C</a></td>
</tr>
<tr>
<td><a class="navnav" href="024_c_mysql_001.html#mj12dab301033f9fd856aa739270c45e08">24 MySQL und C</a></td>
</tr>
<tr>
<td><a class="navnav" href="025_c_netzwerkprogrammierung_001.html#mja8101c6e0e4cb2e6fd8312114dad30d7">25 Netzwerkprogrammierung und Cross&ndash;Plattform-Entwicklung</a></td>
</tr>
<tr>
<td><a class="navnav" href="026_c_paralleles_rechnen_001.html#mj710dc0ad851d57e60533f8797ff9c1e6">26 Paralleles Rechnen</a></td>
</tr>
<tr>
<td><a class="navnav" href="027_c_sicheres_programmieren_001.html#mj13eba8f9d68ac8414bffaa3a1b24ec31">27 Sicheres Programmieren</a></td>
</tr>
<tr>
<td><a class="navnav" href="028_c_weiterfuehrendes_001.html#mj3e65f750149ade087925f303b3871af9">28 Wie geht&#8217;s jetzt weiter?</a></td>
</tr>
<tr>
<td><a class="navnav" href="029_c_anhang_a_001.html#mjec9bf1c5e3fe2e46047c2f9c7aa9c531">A Operatoren</a></td>
</tr>
<tr>
<td><a class="navnav" href="030_c_anhang_b_001.html#mj803443bb6e7546011c48e6e57fbdbb64">B Die C-Standard-Bibliothek</a></td>
</tr>
<tr>
<td><a class="navnav" href="stichwort.html#_top">Stichwort</a></td>
</tr>
<!--<tr>
<td><br><a href="http://download.galileo-press.de/openbook/c_von_a_bis_z/galileocomputing_c_von_a_bis_z.zip" class="navnav"><strong>Download:</strong><br>- ZIP, ca. 10,3 MB</a></td>
</tr>-->
<tr>
<td><br><a href="https://www.rheinwerk-verlag.de/2132/?GPP=opc3" class="navnav">Buch bestellen</a></td>
</tr>
<tr>
<td><a class="navnav" href="#kommentar">Ihre Meinung?</a><br><br></td>
</tr>
</table>
</td>
<td width="10"><img src="common/spacer10.gif" width="10" height="10" alt="Spacer"></td>
<td width="85%" valign="top" align="center"><div align="center">
<table width="98%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a href="020_c_headerdateien_003.html" class="navnav"> &lt;&lt;   zurück</a></td>
<td width="49%"><div align="center"><a href="https://www.rheinwerk-verlag.de/?GPP=opc3" class="navnav">Rheinwerk Computing</a> / <a href="https://www.rheinwerk-verlag.de/openbook/?GPP=opc3" class="navnav">&lt;openbook&gt;</a> / <a href="index-2.html" class="navnav"> C von A bis Z</a></div></td>
<td align="right" width="25%"><div align="right"><a href="020_c_headerdateien_005.html" class="navnav">vor   &gt;&gt; </a></div></td>
</tr>
</table></td>
</tr>
<tr>
<td width="100%" valign="top"><table width="100%" border="0" cellpadding="10" cellspacing="0" class="box">
<tr>
<td colspan="2"><a href="https://www.rheinwerk-verlag.de/2132/?GPP=opc3" class="buchtitel">C von A bis Z</a><span class="autor"> von J&uuml;rgen Wolf </span><br><span class="untertitel">Das umfassende Handbuch</span></td>
</tr>
<tr>
<td valign="top" width="211"><dl>
<dt><a href="https://www.rheinwerk-verlag.de/2132/?GPP=opc3" class="navnav"><img src="common/9783836214117.gif" border="0" alt="Buch: C von A bis Z" title="Buch: C von A bis Z"></a></dt>
<dd><br><a href="https://www.rheinwerk-verlag.de/2132/?GPP=opc3"><span class="autor"><strong>C von A bis Z</strong><br>3., aktualisierte und erweiterte Auflage, geb., mit CD und Referenzkarte<br>1.190 S., 39,90 Euro<br>Rheinwerk Computing<br>ISBN 978-3-8362-1411-7</span></a></dd>
</dl></td>
<td width="80%"><table border="0">
<tr>
<td valign="baseline"><img src="common/pfeil_u.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="3" class="kap"><strong><a href="020_c_headerdateien_001.html#mjf3caede8ebd504dc6b7454b297c251e8" class="navnav">20 Weitere Headerdateien und ihre Funktionen (ANSI C)</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="020_c_headerdateien_001.html#mj9f8d3b308134a5aaa46461b1a2589550" class="navnav">20.1 &lt;assert.h&gt; &#8211; Testmöglichkeiten und Fehlersuche</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="020_c_headerdateien_002.html#mj0a6bced37e99b8b7065f85e18fdf8b71" class="navnav">20.2 &lt;ctype.h&gt; &#8211; Zeichenklassifizierung und Umwandlung</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="020_c_headerdateien_003.html#mj0f16c6b725afe9b7ffd4996bb672f61f" class="navnav">20.3 Mathematische Funktionen &#8211; &lt;math.h&gt;, &lt;tgmath.h&gt; und &lt;complex.h&gt;</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="020_c_headerdateien_003.html#mj1bfb5c2a4254dafa5d130a0b496b8b14" class="navnav">20.3.1 Funktionen für reelle und komplexe Gleitpunkttypen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="020_c_headerdateien_003.html#mj416efc0fd9cf73abf278d7e788cb268f" class="navnav">20.3.2 Funktionen nur für reelle Gleitpunkttypen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="020_c_headerdateien_003.html#mj7fa0739503abf63b431bc987b3ade924" class="navnav">20.3.3 Funktionen nur für komplexe Gleitpunkttypen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="020_c_headerdateien_003.html#mj33c76324b88b714ce9d4a6eb231cfecd" class="navnav">20.3.4 Typengenerische Makros &#8211; &lt;tgmath.h&gt;</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="020_c_headerdateien_003.html#mjcb4411acd264e6126686705c07d0f648" class="navnav">20.3.5 Gleitpunktwerte klassifizieren</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="020_c_headerdateien_003.html#mjd213e5099b73a25f9e709c3bf41f25bc" class="navnav">20.3.6 Makro zum Vergleichen von reellen Zahlen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="020_c_headerdateien_003.html#mjbcf4d91be50bcf5aac0190cd3f4d17ff" class="navnav">20.3.7 Zugriff auf die Gleitpunkt-Umgebung &#8211; &lt;fenv.h&gt;</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="#mj8cf74868e591d838ac6bbb39870c16f9" class="navh">20.4 &lt;stdlib.h&gt;</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mja290ae24149243d0c27b1263dbea5ca6" class="navh">20.4.1 Programmbeendigung &#8211; »exit()«, »_exit()«, »atexit()« und »abort()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj7a0db78d2aab8c704b99a76bb707811e" class="navh">20.4.2 Strings in numerische Werte konvertieren</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj2d5204ba382ea3d12e15e4afed3edd06" class="navh">20.4.3 Bessere Alternative &#8211; Strings in numerische Werte konvertieren</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj5f75e2e5e52fe8e44485e26cdd9a7033" class="navh">20.4.4 Zufallszahlen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjeb70e1048b4b6e44c59c87ba2872d927" class="navh">20.4.5 Absolutwerte, der Quotient und der Rest von Divisionen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj2319f64dfed6d47fc1635eaa1710f61f" class="navh">20.4.6 Suchen und Sortieren &#8211; »qsort()« und »bsearch()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjc5b2f4cf59a876a6169f98eb2ce5af69" class="navh">20.4.7 system()</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="020_c_headerdateien_005.html#mjd60db72bc09fbac4333c4cc6675bddf8" class="navnav">20.5 &lt;locale.h&gt; &#8211; länderspezifische Eigenheiten</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="020_c_headerdateien_006.html#mj70d7263e226c962a009018276d98df74" class="navnav">20.6 Nicht-lokale Sprünge &#8211; &lt;setjmp.h&gt;</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="020_c_headerdateien_007.html#mj2f65e0fff3842c9c42eeb875d5195d9a" class="navnav">20.7 &lt;signal.h&gt;</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="020_c_headerdateien_008.html#mjc47d9d3942da5f467e4a707d52056aae" class="navnav">20.8 &lt;string.h&gt; &#8211; die »mem…«-Funktionen zur Speichermanipulation</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="020_c_headerdateien_008.html#mj30a1672cf88a8a218edce85e59b34fda" class="navnav">20.8.1 »memchr()« &#8211; Suche nach einzelnen Zeichen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="020_c_headerdateien_008.html#mj89123d88032785aac1c497156d40b0c2" class="navnav">20.8.2 »memcmp()« &#8211; bestimmte Anzahl von Bytes vergleichen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="020_c_headerdateien_008.html#mjf5d0bcd9c03e8bd44b91050efaffdb2c" class="navnav">20.8.3 »memcpy()« &#8211; bestimmte Anzahl von Bytes kopieren</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="020_c_headerdateien_008.html#mj00b467f0860e9b679fa3138df5b58a03" class="navnav">20.8.4 »memmove()« &#8211; bestimmte Anzahl von Bytes kopieren</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="020_c_headerdateien_008.html#mja091d2fbcbb374c513cf4df41d62621c" class="navnav">20.8.5 »memset()« &#8211; Speicherbereich mit bestimmten Zeichen auffüllen</a></strong></td>
</tr>
</table><br></td>
</tr>
</table>
<table width="100%" cellpadding="20" cellspacing="0" border="0" bgcolor="#eeeeee">
<tr>
<td><div class="main"><a id="mj8cf74868e591d838ac6bbb39870c16f9" name="mj8cf74868e591d838ac6bbb39870c16f9"></a><a name="t21"></a><a name="t2t31"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div>
<h2 class="t2"><span class="cfett">20.4</span><span class="cfett"> &lt;stdlib.h&gt;</span>  <a href="#t2t32"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><img src="common/15x15leer.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></h2>
<p>In der Headerdatei <span class="ckursiv">&lt;stdlib.h&gt;</span> befinden sich außer den Funktionen zum Allozieren von Speicherplatz noch weitere nützliche Funktionen.</p><a id="mja290ae24149243d0c27b1263dbea5ca6" name="mja290ae24149243d0c27b1263dbea5ca6"></a><a name="t31"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div><a name="t2t32"></a><h3 class="t3"><span class="cfett">20.4.1</span><span class="cfett"> Programmbeendigung &#8211; »exit()«, »_exit()«, »atexit()« und »abort()«</span>  <a href="#t2t33"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t31"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Zur normalen Beendigung eines Programms können Sie außer <span class="clisting">return</span> folgende Funktion verwenden:</p>
<div class="listing"><pre class="prettyprint">void exit(int status);</pre></div>
<p>Laut ANSI-C-Standard ist es egal, ob ein Programm mit der Funktion <span class="clisting">exit()</span> oder <span class="clisting">return</span> beendet wird &#8211; mit dem Unterschied, dass über <span class="clisting">exit()</span>das Programm von einer beliebigen Position im Code aus beendet werden kann. Bei <span class="clisting">return</span> gelingt dies nur in der <span class="clisting">main()</span>-Funktion. Der Ablauf von <span class="clisting">exit()</span> lässt sich so erklären: Bei Programmbeendigung mit <span class="clisting">exit()</span> werden zuvor alle gefüllten Puffer geleert, alle geöffneten Dateien geschlossen und alle temporären Dateien gelöscht, die mit der Funktion <span class="clisting">tmpfile()</span> angelegt wurden. Anschließend wird die Routine <span class="clisting">       _exit()</span> aufgerufen, und das Programm beendet sich.</p>
<p>Bei <span class="clisting">exit()</span> gelten die gleichen Rückgabewerte wie beim Beenden der <span class="clisting">main()</span>-Funktion mittels <span class="clisting">return</span>. Ein Rückgabewert von 0 bedeutet, dass ein Programm ordentlich beendet wurde &#8211; ein Wert ungleich 0 hingegen sagt aus, dass etwas nicht ordnungsgemäß abgeschlossen wurde. Da dies, wie schon in Abschnitt 9.17 erwähnt wurde, nicht unbedingt so implementiert sein muss, sind Sie auch hier mit den Standard-C-Makros <span class="clisting">EXIT_SUCCESS</span> (für eine erfolgreiche Beendigung) und <span class="clisting">EXIT_FAILURE</span> (bei einem Fehler) als Parameter für <span class="clisting">exit()</span>auf der sicheren Seite.</p>
<p>Theoretisch kann die Funktion <span class="clisting">_exit</span> auch gleich aufgerufen werden. Dies entspricht allerdings nicht dem ANSI-C-Standard. Hier sehen Sie die Syntax:</p>
<div class="listing"><pre class="prettyprint">#include &lt;unistd.h&gt;    /* unter Linux/UNIX */
#include &lt;stdlib.h&gt;    /* unter MS-DOS     */

void _exit(int status);</pre></div>
<p>Damit werden die oben genannten »Aufräumarbeiten« nicht vorgenommen.</p>
<p>Eine weitere Funktion für Beendigungsroutinen in der Headerdatei <span class="ckursiv">&lt;stdlib.h&gt;</span> ist die Funktion <span class="clisting">atexit()</span>. Die Syntax sieht so aus:</p>
<div class="listing"><pre class="prettyprint">#include &lt;stdlib.h&gt;

int atexit(void (*funktion) (void));</pre></div>
<p>Mit <span class="clisting">atexit()</span> wird ein sogenannter Funktionshandler eingerichtet. Alle Funktionen, die in <span class="clisting">atexit()</span> angegeben sind, werden in einer Funktionsliste eingetragen und bei Beendigung des Programms in umgekehrter Reihenfolge ausgeführt, also nach dem LIFO-Prinzip (Last In First Out). Laut ANSI C können insgesamt 32 solcher Funktionen verwendet werden. Hierzu ein Beispiel:</p>
<div class="listing"><pre class="prettyprint">/* atexit1.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void funktion1(void) {
   printf("Die Funktion funktion1 wurde aufgerufen\n");
}

void funktion2(void) {
   printf("Die Funktion funktion2 wurde aufgerufen\n");
}

int main(void) {
   atexit(funktion1);
   atexit(funktion2);
   printf("Wir beenden unser Programm\n");
   exit(EXIT_FAILURE);
   printf("Dies wird nicht mehr ausgegeben\n");
   return EXIT_SUCCESS;
}</pre></div>
<p>Solch ein Beispiel macht natürlich wenig Sinn. Sie können <span class="clisting">atexit()</span> beispielsweise verwenden, um Logdateien zu schreiben, etwa wenn der User das Programm beendet oder wenn ein Programm mit einem Fehler beendet wurde. Oder Sie können noch diverse Aufräumarbeiten durchführen, wie es im folgenden Beispiel geschieht:</p>
<div class="listing"><pre class="prettyprint">/* atexit2.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

char *memPtr;

void free_malloc(void) {
   /* Wurde überhaupt Speicher reserviert? */
   if(memPtr == NULL)
      printf("Kein Speicher war reserviert!!!\n");
   else {
      free(memPtr);
      printf("Speicher wurde freigegeben!!\n");
   }
}

int main(void) {
   memPtr =(char *) malloc(10000);

   if(memPtr==NULL)
      printf("Konnte keinen Speicher reservieren\n");
   if(atexit (free_malloc) != 0)
      printf("Konnte Funktionshandler nicht einrichten\n");

   /* Nach vielen Zeilen Code beenden wir das Programm. */
   printf("Ein Fehler - Programm wird beendet - \n");
   exit(EXIT_FAILURE);
   printf("Wird nicht mehr ausgegeben\n");
   return EXIT_SUCCESS;
}</pre></div>
<p>Die nächste Funktion zur Beendigung (oder in diesem Fall besser gesagt zur abnormalen Beendigung eines Programms) ist die Funktion <span class="clisting">abort()</span>. Die Syntax lautet:</p>
<div class="listing"><pre class="prettyprint">#include &lt;stdlib.h&gt;

void abort(void);</pre></div>
<p>Diese Funktion bewirkt &#8211; wie der Name schon sagt &#8211; eine abnormale Programmbeendigung. <span class="clisting">abort()</span> schickt dem aufrufenden Prozess das Signal <span class="clisting">SIGABRT</span>. Dieses Signal sollte niemals ignoriert werden. Hier ein Mini-Beispiel dazu:</p>
<div class="listing"><pre class="prettyprint">/* abort.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void) {
   abort();
   return EXIT_SUCCESS;
}</pre></div>
<p>Das Programm wird mit folgender Fehlermeldung beendet:</p>
<div class="listing"><pre class="prettyprint">Abnormal Programm termination</pre></div>
<p>Hier wurde die Fehlerausgabe über <span class="clisting">stderr</span> realisiert. Im Gegensatz zur Funktion <span class="clisting">exit()</span> gibt es bei der Funktion <span class="clisting">abort()</span> keine Vorgaben, ob der Ausgabepuffer geleert oder die temporären Dateien automatisch gelöscht werden. Somit ist diese Funktion nicht für Programme geeignet, die auf mehreren Systemen laufen müssen. Ebenso werden nach einem <span class="clisting">abort()</span>-Aufruf die Funktionen, die mit <span class="clisting">atexit()</span> eingerichtet wurden, nicht mehr ausgeführt.</p>
<p>POSIX.1 hingegen schreibt vor, dass zumindest alle noch offenen Standard-E/A-Streams mit <span class="clisting">fclose()</span> ordentlich geschlossen werden müssen.</p><a id="mj7a0db78d2aab8c704b99a76bb707811e" name="mj7a0db78d2aab8c704b99a76bb707811e"></a><a name="t32"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div><a name="t2t33"></a><h3 class="t3"><span class="cfett">20.4.2</span><span class="cfett"> Strings in numerische Werte konvertieren</span>  <a href="#t2t34"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t32"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Müssen Sie einen String in einen numerischen Wert konvertieren, gibt es hierfür in der Headerdatei <span class="ckursiv">&lt;stdlib.h&gt;</span> gleich mehrere Funktionen. Einen String in einen <span class="clisting">int</span>-Wert umwandeln können Sie mit folgender Funktion:</p>
<div class="listing"><pre class="prettyprint">int atoi(char *string);</pre></div>
<p>Ein String kann in einen <span class="clisting">long int</span>-Wert mit der Funktion</p>
<div class="listing"><pre class="prettyprint">long int atol(char *string);</pre></div>
<p>umgewandelt werden, und soll ein <span class="clisting">double</span>-Wert aus einem String werden, dann ist diese Funktion verfügbar:</p>
<div class="listing"><pre class="prettyprint">double atof(char *string);</pre></div>
<p>Es soll ein Programm geschrieben werden, das z. B. folgende Eingabe von der Kommandozeile verarbeiten kann:</p>
<div class="listing"><pre class="prettyprint">typen 5 5.55 A 255555 3E234</pre></div>
<p>Die Ausgabe sollte dann so aussehen:</p>
<div class="bildbox">
<p><a name="IDAUWUQ"></a><a onClick="OpenWin('bilder/20_001.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein20_001.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 20.1    </strong>Strings in numerische Werte konvertieren</p>
<p>Hier sind der Quellcode und die Funktionen <span class="clisting">atof()</span> und <span class="clisting">atol()</span>:</p>
<div class="listing"><pre class="prettyprint">/* string2val1.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;float.h&gt;
#include &lt;limits.h&gt;

int main(int argc, char *argv[]) {
   if(argc==1) {
      printf("Keine Zahlen zum Auswerten vorhanden!\n");
      return EXIT_FAILURE;
   }
   while(*++argv) {
      if(strchr(*argv,'.') || strchr(*argv,'e') ||
       strchr(*argv,'E')) {
         if(((atof(*argv)) &lt;= FLT_MAX)&amp;&amp;
          ((atof(*argv)) &gt;= FLT_MIN)) {
            printf("\n%s ist ein float-Wert\n", *argv);
            printf("Maximaler float-Wert:%f\n", FLT_MAX);
            printf("Kleinster pos. float-Wert : %f\n" , FLT_MIN);
         }
         else if(((atof(*argv)) &lt;= DBL_MAX)&amp;&amp;
          ((atof(*argv)) &gt;= DBL_MIN)) {
            printf("\n%s ist ein double-Wert\n", *argv);
            printf("Max. double-Wert:%f\n", DBL_MAX);
            printf("Kleinster pos. double-Wert : %f\n", DBL_MIN);
         }
      }
      else if(((atol(*argv)) &lt; SHRT_MAX)&amp;&amp;
       ((atol(*argv))&gt;SHRT_MIN) &amp;&amp; (atol(*argv) != 0)) {
         printf("\n%s ist ein short int-Wert\n",*argv);
         printf("Maximaler short int-Wert: %d\n",SHRT_MAX);
         printf("Kleinster short int-Wert: %d\n",SHRT_MIN);
      }
      else if(((atol(*argv)) &lt; LONG_MAX) &amp;&amp;
       ((atol(*argv)) &gt; LONG_MIN) &amp;&amp; (atol(*argv) != 0)) {
         printf("\n%s ist ein long-Wert\n",*argv);
         printf("Maximaler long-Wert : %ld\n",LONG_MAX);
         printf("Kleinster long-Wert : %ld\n",LONG_MIN);
      }
      else
         printf("\nUnbekannter Typ (%s)!\n",*argv);
      }
    return EXIT_SUCCESS;
}</pre></div>
<p>Es wurde hier nicht auf alle Datentypen geprüft, und anderweitig ist das Programm auch nicht wasserdicht. Aber dies würde den Rahmen dieses Kapitels sprengen. Hier wurden außerdem die (ANSI-C-)Konstanten aus den Headerdateien <span class="ckursiv">&lt;float.h&gt;</span> und <span class="ckursiv">&lt;limits.h&gt;</span> verwendet, damit das Programm auch auf jedem System läuft &#8211; egal, welche Grenzen gesetzt sind.</p><a id="mj2d5204ba382ea3d12e15e4afed3edd06" name="mj2d5204ba382ea3d12e15e4afed3edd06"></a><a name="t33"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div><a name="t2t34"></a><h3 class="t3"><span class="cfett">20.4.3</span><span class="cfett"> Bessere Alternative &#8211; Strings in numerische Werte konvertieren</span>  <a href="#t2t35"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t33"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Sicherlich ist Ihnen an der Methode (im Listing <span class="ckursiv">string2va1.c</span>) mit <span class="clisting">atof()</span> bzw. <span class="clisting">atol()</span> aufgefallen, dass diese Funktionen recht unflexibel sind und vor allem das Manko haben, keinen Fehler bei der Eingabe feststellen zu können. Eine häufig gestellte Frage lautet nämlich, wie man prüfen könne, ob der richtige Datentyp eingegeben wurde. Und genau diese »bessere« Alternative stellt Ihnen die Standard-Bibliothek mit den Funktionen <span class="clisting">strtod()</span> und <span class="clisting">strtol()</span> zur Verfügung. Beide Funktionen sind ebenfalls in der Headerdatei <span class="ckursiv">&lt;stdlib.h&gt;</span> enthalten. Zuerst die Funktion <span class="clisting">strtod()</span>:</p>
<div class="listing"><pre class="prettyprint">double strtod(
   const char * restrict string,
   char ** restrict endptr );</pre></div>
<p><span class="clisting">strtod()</span> konvertiert einen String in einen <span class="clisting">double</span>-Wert. <span class="clisting">strtod()</span> bricht die Analyse beim ersten Zeichen ab, das nicht mehr als Teil eines <span class="clisting">double</span>-Werts interpretiert werden kann. Solange der Parameter <span class="clisting">endptr</span> nicht <span class="clisting">NULL</span> ist, wird <span class="clisting">*endptr</span> von <span class="clisting">strtod()</span> auf das Zeichen innerhalb von <span class="clisting">string</span> gesetzt, durch das die Analyse abgebrochen wurde (<span class="clisting">*endptr=&amp;abbruch_zeichen</span>).</p>
<div class="listing"><pre class="prettyprint">long strtol(
   const char * restrict string,
   char ** restrict endptr, int basis );</pre></div>
<p><span class="clisting">strtol()</span> konvertiert einen String in einen <span class="clisting">long</span>-Wert. <span class="clisting">basis</span> legt das Zahlensystem fest, in das die Zahl umgewandelt werden soll (Basis = 8 ist Oktalzahl, Basis = 16 (0&#8211;9, A&#8211;F) ist eine Hexadezimalzahl, Basis = 10 ist das Dezimalsystem). Für <span class="clisting">basis</span> sind Werte von 2 bis 36 möglich. Für <span class="clisting">endptr</span> können Sie den <span class="clisting">NULL</span>-Zeiger angeben. Falls kein <span class="clisting">NULL</span>-Zeiger angegeben wird, zeigt <span class="clisting">endptr</span> auf den Rest des <span class="clisting">long</span>-Werts (sollte einer übrig bleiben). Für diese Funktion gibt es auch den <span class="clisting">unsigned</span>-Bruder mit derselben Bedeutung:</p>
<div class="listing"><pre class="prettyprint">unsigned long strtoul(const char *string,
                     char **end_ptr,int basis);</pre></div>
<p>Im Falle eines Fehlers liefern all diese Funktionen 0 zurück. Wird der Wertebereich des zu konvertierenden Typs unter- bzw. überschritten (bei <span class="clisting">long</span> sind dies <span class="clisting">LONG_MIN</span> bzw. <span class="clisting">LONG_MAX</span>), wird <span class="clisting">errno</span> auf <span class="clisting">ERANGE</span> gesetzt. Somit können Sie, wenn der Rückgabewert der Funktionen nicht 0, der <span class="clisting">end_ptr</span> gleich <span class="clisting">NULL</span> und die Fehlervariable <span class="clisting">errno</span> nicht <span class="clisting">ERANGE</span> ist, mit ziemlicher Sicherheit davon ausgehen, dass die von Ihnen eingegebene Zahl richtig ist (eine 100  %ige Garantie gibt es aber nicht).</p>
<p>Hier ein kurzes Beispiel, das den gleichwertigen Fall von <span class="clisting">atol()</span> und <span class="clisting">strtol()</span> demonstrieren soll:</p>
<div class="listing"><pre class="prettyprint">/* string2val2.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void) {
   char string1[] =  "256Vorrat";
   char string2[]=   "128Benoetigt";
   long zahl1, zahl2;

   zahl1 = atol(string1);
   zahl2 = strtol(string2, NULL, 10);
   printf("zahl1: %ld; zahl2: %ld\n", zahl1, zahl2);
   return EXIT_SUCCESS;
}</pre></div>
<p>Hierbei wird »korrekterweise« einmal die Zahl 256 und einmal 128 ausgegeben. Beide Funktionen konvertieren also bis zum ersten Zeichen, das nicht mehr zum Datentyp gehört. Was aber, wenn eine derartige Eingabe überprüft werden soll &#8211; denn eigentlich sind ja beide Strings keine »korrekten« Zahlen, sondern nur Strings, die eben Zahlen beinhalten bzw. die mit Zahlen beginnen. Eben hier ist <span class="clisting">atol()</span> am Ende. Mit <span class="clisting">strtol()</span> hingegen haben Sie hierbei noch den zweiten Parameter, der Ihnen dabei helfen wird.</p>
<p>Daher soll hier ein Beispiel erstellt werden, das jeweils zweimal die Eingabe eines Strings erfordert und überprüft, ob es sich dabei um einen »echten« <span class="clisting">long</span>-Wert handelt (<span class="clisting">strtol()</span>), und noch eine Funktion hat, die überprüft, ob sich der String korrekt in einen <span class="clisting">double</span>-Wert konvertieren lässt (<span class="clisting">mit strtod()</span>).</p>
<div class="listing"><pre class="prettyprint">/* check_input.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#define CHARS 20

void chomp(char *str) {
   size_t p=strlen(str);
   /* '\n' mit '\0' ueberschreiben */
   str[p-1]='\0';
}

void is_long(char *str) {
   static long val;
   char *stop_ptr = NULL;

   val = strtoul(str, &amp;stop_ptr, 10);
   if(errno == ERANGE) {
      printf("Werteueber- bzw. unterlauf!!!\n");
      exit(EXIT_FAILURE);
   }
   if(!val) {
      printf("Wert konnte nicht umgewandelt werden\n");
      exit(EXIT_FAILURE);
   }
   if(*stop_ptr) {
      printf("Kein korrekter long-Wert: %s\n", str);
      printf("Fehler der Umwandlung ab Pos.: %s\n", stop_ptr);
      printf("Umgewandelt ---&gt; %ld\n", val);
   }
   else
      printf("Yeah! Korrekter long-Wert : %ld\n", val);
}

void is_double(char *str) {
   static double val;
   char *stop_ptr = NULL;

   val = strtod(str, &amp;stop_ptr);
   if(errno == ERANGE) {
      printf("Werteueber- bzw. unterlauf!!!\n");
      exit(EXIT_FAILURE);
   }
   if(!val) {
      printf("Wert konnte nicht umgewandelt werden\n");
      exit(EXIT_FAILURE);
   }
   if(*stop_ptr) {
      printf("Kein korrekter double-Wert: %s\n", str);
      printf("Fehler der Umwandlung ab Pos.: %s\n", stop_ptr);
      printf("Umgewandelt ---&gt; %lf\n", val);
   }
   else
      printf("Yeah! Korrekter double-Wert : %lf\n", val);
}

int main(void) {
   char val[CHARS];
   /* Testen eines long-Wertes */
   printf("Bitte geben Sie einen long-Wert ein : ");
   fgets(val, CHARS, stdin);
   chomp(val);
   is_long(val);
   /* Gleiches nochmals mit einem double-Wert */
   printf("Bitte geben Sie einen double-Wert ein : ");
   fgets(val, CHARS, stdin);
   chomp(val);
   is_double(val);

   return EXIT_SUCCESS;
}</pre></div>
<p>Sofern Sie jetzt hierbei auf andere Typen wie beispielsweise <span class="clisting">int</span> überprüfen wollen, müssen Sie dazu die Limit-Konstanten der Headerdatei <span class="ckursiv">&lt;limits.h&gt;</span> (beispielsweise <span class="clisting">INT_MIN</span> oder <span class="clisting">INT_MAX</span>) verwenden und mit dem <span class="clisting">long</span>-konvertieren Wert vergleichen.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellenkopf"><span class="cfett">Hinweis</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p class="BStandard">Sofern Ihr Compiler den ISO-C99-Standard versteht, finden Sie hierbei noch weitere solcher sehr nützlichen Funktionen mit <span class="clisting">strtoll()</span> (String to <span class="clisting">long</span> <span class="clisting">long</span>), <span class="clisting">strtoimax()</span> (String to <span class="clisting">intmax_t</span>; Funktion in <span class="clisting">&lt;inttypes.h&gt;</span>), <span class="clisting">strtoumax()</span> (String to <span class="clisting">uintmax_t</span>; Funktion in <span class="clisting">&lt;inttypes.h&gt;</span>), <span class="clisting">strtof()</span> (String to <span class="clisting">float</span>) und <span class="clisting">strtold()</span> (String to <span class="clisting">long</span> <span class="clisting">double</span>). Mehr dazu entnehmen Sie dann der Dokumentation Ihres Compilers (beispielsweise der Manual-Page). Ebenso stehen Ihnen auch die Funktionen zur Konvertierung von Zahlen und breiten Strings zur Verfügung. Die entsprechenden Gegenstücke haben alle das Präfix <span class="clisting">w</span> vorangestellt und sind in der Headerdatei &lt;wchar.h&gt; definiert. Lediglich zu <span class="clisting">atoi()</span> gibt es hier kein Gegenstück für breite Zeichen.</p>
</td>
</tr>
</table><br><p>Eine häufige Frage lautet: Wo ist <span class="clisting">itoa()</span>, oder wie kann ich einen Integerwert in einen String konvertieren? <span class="clisting">itoa()</span> ist keine ANSI-C-Standardfunktion, und daher hängt es vom Compiler ab, ob diese Funktion vorhanden ist oder nicht. Sollten Sie aber portabel bleiben müssen, macht diese Funktion ohnehin keinen Sinn. Also basteln Sie sich diese Funktion selbst zusammen:</p>
<div class="listing"><pre class="prettyprint">/* my_itoa.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

char *my_itoa(int wert, int laenge) {
   char *ret =(char *) malloc(laenge+1 * sizeof(char));
   int i;

   for(i  =0; i &lt; laenge; i++) {
      ret[laenge-i-1] = (wert % 10) + 48;
      wert = wert / 10;
   }
   ret[laenge]='\0';
   return ret;
}

int main(void) {
   printf("%s\n", my_itoa(1234,4));
   printf("%s\n", my_itoa(5432,6));
   return EXIT_SUCCESS;
}</pre></div>
<p>Falls für die Länge zu viele Zahlen angegeben wurden, werden diese mit voranstehenden Nullen gefüllt.</p>
<p>Da ich in diesem Kapitel nur auf die Funktionen zum Konvertieren zwischen Zahlen und Strings aus der Headerdatei <span class="ckursiv">&lt;stdlib.h&gt;</span> eingegangen bin, es aber auch weitere Funktionen für breite Zeichen in <span class="ckursiv">&lt;wchar.h&gt;</span> und ganzzahlige Typen maximaler Breite in <span class="ckursiv">&lt;inttypes.h&gt;</span> gibt (siehe Anhang B), folgt hier eine Tabelle mit einem Überblick, mit welcher Funktion Sie am besten einen String in welchen Typ konvertieren.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<caption class="tabunter"><p class="ptabunter"><strong>Tabelle 20.11    </strong>Übersicht zu Funktionen zum Konvertieren von Strings in Zahlen</p>
</caption>
<tr>
<td class="tabellenkopf"><span class="cfett">String zu...</span>
</td>
<td class="tabellenkopf"><span class="cfett">&lt;stdlib.h&gt;</span>
</td>
<td class="tabellenkopf"><span class="cfett">&lt;inttypes.h&gt; </span><span class="cfett"><sup>1)  </sup></span>
</td>
<td class="tabellenkopf"><span class="cfett">&lt;wchar.h&gt; </span><span class="cfett"><sup>1)  </sup></span>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint"><span class="cfett">int</span></pre></div>
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">atoi()</pre></div>
</td>
<td class="tabellentext">
</td>
<td class="tabellentext">
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint"><span class="cfett">long</span></pre></div>
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">strtol()</pre></div>
</td>
<td class="tabellentext">
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">wcstol()</pre></div>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint"><span class="cfett">unsigned long</span></pre></div>
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">strtoul()</pre></div>
</td>
<td class="tabellentext">
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">wcstoul()</pre></div>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint"><span class="cfett">long long</span></pre></div>
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">strtoll()</pre></div>
</td>
<td class="tabellentext">
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">wcstoll()</pre></div>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint"><span class="cfett">unsigned long long</span></pre></div>
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">strtoull()</pre></div>
</td>
<td class="tabellentext">
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">wcstoull()</pre></div>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint"><span class="cfett">float</span></pre></div>
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">strtof()</pre></div>
</td>
<td class="tabellentext">
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">wcstof()</pre></div>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint"><span class="cfett">double</span></pre></div>
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">strtod()</pre></div>
</td>
<td class="tabellentext">
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">wcstod()</pre></div>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint"><span class="cfett">long double</span></pre></div>
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">strtold()</pre></div>
</td>
<td class="tabellentext">
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">wcstold()</pre></div>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint"><span class="cfett">intmax_t</span></pre></div>
</td>
<td class="tabellentext">
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">strtoimax()</pre></div>
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">wcstoimax()</pre></div>
</td>
</tr>
<tr>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint"><span class="cfett">uintmax_t</span></pre></div>
</td>
<td class="tabellentext">
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">strtoumax()</pre></div>
</td>
<td class="tabellentext">
<div class="listing"><pre class="prettyprint">wcstoumax()</pre></div>
</td>
</tr>
<tr>
<td class="tabellentext" colspan="4">
<p><sup>1)  </sup> Headerdatei und Funktionen erst seit dem C99-Standard verfügbar</p>
</td>
</tr>
</table><br><a id="mj5f75e2e5e52fe8e44485e26cdd9a7033" name="mj5f75e2e5e52fe8e44485e26cdd9a7033"></a><a name="t34"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div><a name="t2t35"></a><h3 class="t3"><span class="cfett">20.4.4</span><span class="cfett"> Zufallszahlen</span>  <a href="#t2t36"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t34"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Die Funktion</p>
<div class="listing"><pre class="prettyprint">int rand(void);</pre></div>
<p>liefert eine Pseudo-Zufallszahl im Bereich 0 bis <span class="clisting">RAND_MAX</span> zurück, beispielsweise mit:</p>
<div class="listing"><pre class="prettyprint">/* zufall1.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void) {
   int zufallszahl, i;

   for(i = 0; i &lt; 5; i++)
      printf("Die Zufallszahl lautet %d\n", zufallszahl=rand());
   return EXIT_SUCCESS;
}</pre></div>
<p>Bei Ausführung des Listings werden fünf verschiedene Zufallszahlen zwischen 0 und <span class="clisting">RAND_MAX</span> ausgegeben. Aber spätestens, wenn das Programm jetzt ein zweites Mal gestartet wird, merken Sie, dass sich diese Zufallszahlen immer wiederholen. Das Problem an der Funktion <span class="clisting">rand()</span> ist, dass diese immer denselben Startpunkt zur Berechnung der Zufallszahl benutzt. Anders dagegen die Funktion:</p>
<div class="listing"><pre class="prettyprint">void srand(unsigned int startwert);</pre></div>
<p>Mit ihr kann der Startpunkt für die Zufallszahl selbst bestimmt werden.</p>
<p>Ein Beispiel:</p>
<div class="listing"><pre class="prettyprint">/* zufall2.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void) {
   int zufallszahl, i, startpunkt;

   printf("Geben Sie irgendeine Zahl ein : ");
   scanf("%d",&amp;startpunkt);
   srand(startpunkt);
   for(i = 0; i &lt; 5; i++)
      printf("Die Zufallszahl lautet  %d\n", zufallszahl=rand());
   return EXIT_SUCCESS;
}</pre></div>
<p>Jetzt wollen Sie aber sicher nicht andauernd einen Startwert für den Zufallsgenerator eingeben. Zum einen ist dies umständlich, und zum anderen bekommen Sie wieder dieselbe Zahl zurück, sollte zweimal der gleiche Wert eingegeben werden. Was eignet sich also besser als die Funktion <span class="clisting">time()</span> für den Startwert. Und wie gehen Sie vor, falls eine Zufallszahl im Bereich zwischen 1 und 10 benötigt wird? Hier eignet sich der Modulo-Operator bestens. Ein entsprechendes Beispiel wäre:</p>
<div class="listing"><pre class="prettyprint">/* zufall3.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

int main(void) {
   int zufallszahl, i;

   srand(time(NULL));
   for(i = 0; i &lt; 5; i++)
      printf("Zufallszahl lautet %d\n", zufallszahl=rand()%10+1);
   return EXIT_SUCCESS;
}</pre></div>
<p>Jetzt erhalten Sie schon etwas bessere Zufallszahlen im Bereich zwischen 1 und 10.</p><a id="mjeb70e1048b4b6e44c59c87ba2872d927" name="mjeb70e1048b4b6e44c59c87ba2872d927"></a><a name="t35"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div><a name="t2t36"></a><h3 class="t3"><span class="cfett">20.4.5</span><span class="cfett"> Absolutwerte, der Quotient und der Rest von Divisionen</span>  <a href="#t2t37"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t35"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Um Absolutwerte von Ganzzahlen zu ermitteln, können zwei Funktionen verwendet werden:</p>
<div class="listing"><pre class="prettyprint">long int labs(long int zahl);
int abs(int zahl);</pre></div>
<p>So erhalten Sie den Absolutwert zum ganzzahligen Argument <span class="clisting">zahl</span>:</p>
<div class="listing"><pre class="prettyprint">/* absolut.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void) {
   int zahl = 5;

   printf("%d\n", abs(zahl-20));
   return EXIT_SUCCESS;
}</pre></div>
<p>Werden der Quotient und der Rest einer Division benötigt, können folgende Funktionen verwendet werden:</p>
<div class="listing"><pre class="prettyprint">div_t div(int zaehler, int nenner);
ldiv_t ldiv(long int zaehler, long int nenner);</pre></div>
<p><span class="clisting">div_t</span> und <span class="clisting">ldiv_t</span> sind Strukturtypen mit folgendem Inhalt:</p>
<div class="listing"><pre class="prettyprint">typedef struct{
   int quot;  /* quotient */
   int rem;   /* remainder */
} div_t;</pre></div>
<p>... bzw. ...</p>
<div class="listing"><pre class="prettyprint">typedef struct{
   long int quot;  /* quotient */
   long int rem;   /* remainder */
} ldiv_t;</pre></div>
<p>Damit berechnen Sie <span class="clisting">zaehler/nenner</span>. Der Rest des Werts steht in <span class="clisting">rem</span>, falls die Rechnung ungenau ist, und der Quotient befindet sich in <span class="clisting">quot</span>. Ein Beispiel:</p>
<div class="listing"><pre class="prettyprint">/* division.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void) {
   div_t x = div(10,3);


   printf("10 div 3 = %d Rest %d\n",  x.quot, x.rem);
   return EXIT_SUCCESS;
}</pre></div>
<p>Diese Funktion macht im Prinzip nichts anderes, als Folgendes zu berechnen:</p>
<div class="listing"><pre class="prettyprint">quot = zaehler / nenner;
rem  = zaehler % nenner;</pre></div>
<p>Neu ab dem C99-Standard sind auch die entsprechenden Gegenstücke <span class="clisting">imaxabs</span><span class="clisting">()</span> und <span class="clisting">imaxdiv</span><span class="clisting">()</span> für den Typ <span class="clisting">intmax_t</span>. Beide Funktionen sind in der Headerdatei <span class="ckursiv">&lt;inttypes.h&gt;</span> definiert und haben folgende Syntax:</p>
<div class="listing"><pre class="prettyprint">#include &lt;inttypes.h&gt;

intmax_t imaxabs(intmax_t j);
imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom);</pre></div><a id="mj2319f64dfed6d47fc1635eaa1710f61f" name="mj2319f64dfed6d47fc1635eaa1710f61f"></a><a name="t36"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div><a name="t2t37"></a><h3 class="t3"><span class="cfett">20.4.6</span><span class="cfett"> Suchen und Sortieren &#8211; »qsort()« und »bsearch()«</span>  <a href="#t2t38"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t36"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Mit der Funktion <span class="clisting">qsort()</span> kann ein Array der Wahl nach beliebigen Kriterien sortiert werden. Die <span class="clisting">qsort()</span>-Funktion basiert auf dem Quicksort-Algorithmus von C.A.R. Hoare. Hier sehen Sie die Syntax von <span class="clisting">qsort()</span> ausführlich dokumentiert:</p>
<div class="listing"><pre class="prettyprint">void qsort(
   void *array,        // Anfangsadresse des Vektors
   size_t n,           // Anzahl der Elemente zum Sortieren
   size_t size,        // Größe des Datentyps, der sortiert wird
   // Jetzt folgt die Vergleichsfunktion
   int (*vergleich_func)(const void*, const void*)   );</pre></div>
<p>Die Bedeutungen der einzelnen Parameter dürften klar sein &#8211; bis auf die Vergleichsfunktion. Diese müssen Sie selbst implementieren. Hierzu ein einfaches Beispiel mit der Funktion <span class="clisting">qsort()</span>:</p>
<div class="listing"><pre class="prettyprint">/* qsort.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* Vergleichsfunktion */
int cmp(const void *ptr1, const void *ptr2) {
   if( *(int *)ptr1 &lt; *(int *)ptr2 )
      return -1;
   else if( *(int *)ptr1 &gt; *(int *)ptr2 )
      return 1;
   else
      return 0;  /* Beide Elemente sind gleich. */
}

int main(void) {
   int wert[] = { 2, 5, 2, 7, 6, 4, 2 };
   int i;

   printf("Daten vor dem Sortieren\n");
   for(i = 0; i &lt; sizeof(wert)/sizeof(int); i++)
      printf("%d\t", wert[i]);
   printf("\n");

   /* jetzt sortieren mit qsort() */
   qsort(wert, sizeof(wert)/sizeof(int), sizeof(int), cmp);

   printf("Daten nach dem Sortieren mit qsort()\n");
   for(i = 0; i &lt; sizeof(wert)/sizeof(int); i++)
      printf("%d\t", wert[i]);
   printf("\n");
   return EXIT_SUCCESS;
}</pre></div>
<p>Das Listing sortiert das unsortierte Integer-Feld <span class="clisting">wert</span>; die Ausgabe des Programms bestätigt dies.</p>
<p>Wollen Sie ein Element wieder in Ihrem sortierten Vektor finden, dann können Sie die Funktion <span class="clisting">bsearch()</span> verwenden. <span class="clisting">bsearch</span> steht für »binäre Suche« und sucht die Elemente, indem es mit der Suche im mittleren Bereich eines Arrays beginnt und je nach Resultat mit der Suche auf der linken oder rechten Hälfte fortfährt. Genaueres dazu erfahren Sie in Kapitel 22, »Algorithmen«. Wird ein entsprechendes Element gefunden, liefert diese Funktion die Adresse zurück. Wird kein entsprechendes Element gefunden, dann wird der <span class="clisting">NULL</span>-Zeiger zurückgegeben. Hier folgt die Syntax:</p>
<div class="listing"><pre class="prettyprint">void *bsearch(
   const void *key,      // gesuchte Elemente
   const void *array,    // Anfangsadresse der Tabelle zum Suchen
   size_t n,             // Anzahl der Elemente
   size_t size,          // Elementgröße
   // Jetzt folgt die Vergleichsfunktion
   int (*vergleich_func)(const void*, const void*)   );</pre></div>
<p>Die Syntax ist also der Funktion <span class="clisting">qsort()</span> recht ähnlich. Zur Abwechslung soll aber hier nach einem String in einer Stringtabelle gesucht werden, die Sie zuvor noch mit <span class="clisting">qsort()</span> sortieren.</p>
<div class="listing"><pre class="prettyprint">/* bsearch.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;string.h&gt;
/* Anzahl der Strings */
#define MAX 5

/* Vergleichsfunktion für zwei Strings */
int cmp_str(const void *s1, const void *s2) {
   return (strcmp(*(char **)s1, *(char **)s2));
}

int main(void) {
   char *daten[MAX], puffer[80], *ptr, *key_ptr, **key_ptrptr;
   int count;

   /* Wörter eingeben */
   printf("Geben Sie %d Wörter ein\n", MAX);
   for (count = 0; count &lt; MAX; count++) {
      printf("Wort %d: ", count+1);
      fgets(puffer, 80, stdin);
      /* Speicher für das Wort Nummer count reservieren */
      daten[count] = (char *) malloc(strlen(puffer)+1);
      strcpy(daten[count], strtok(puffer,"\n") );
   }
   /* die einzelnen Wörter sortieren */
   qsort(daten, MAX, sizeof(daten[0]), cmp_str);
   /* sortierte Daten ausgeben */
   for (count = 0; count &lt; MAX; count++)
      printf("\nWort %d: %s", count+1, daten[count]);

   /* jetzt nach einem Wort suchen */
   printf("\n\nNach welchem Wort wollen Sie suchen: ");
   fgets(puffer, 80, stdin);
   /* Zur Suche übergeben Sie zuerst den puffer an key,
    * danach benötigen Sie einen weiteren Zeiger, der
    * auf diesen Such-Schlüssel zeigt
    */
   key_ptr = strtok(puffer, "\n");
   key_ptrptr = &amp;key_ptr;
   /* Der Zeiger ptr bekommt die Adresse des Suchergebnisses. */
   ptr =(char *) bsearch(key_ptrptr, daten, MAX,
                         sizeof(daten[0]), cmp_str);

   if(NULL == ptr)
      printf("Kein Ergebnis stimmt mit %s überein\n", puffer);
   else
      printf("%s wurde gefunden\n", puffer);
   return EXIT_SUCCESS;
}</pre></div><a id="mjc5b2f4cf59a876a6169f98eb2ce5af69" name="mjc5b2f4cf59a876a6169f98eb2ce5af69"></a><a name="t37"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div><a name="t2t38"></a><h3 class="t3"><span class="cfett">20.4.7</span><span class="cfett"> system()</span>  <img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"><a href="#t2t37"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Um aus einem lauffähigen Programm ein anderes Programm zu starten, steht Ihnen die Funktion <span class="clisting">system()</span> zur Verfügung. Die Syntax lautet:</p>
<div class="listing"><pre class="prettyprint">#include &lt;stdlib.h&gt;

int system(const char *kommandozeile);</pre></div>
<p>Beim Ausführen der Funktion <span class="clisting">system()</span> übergeben Sie den String <span class="clisting">kommandozeile</span> an den Kommandozeilenprozessor. Konnte der Aufruf erfolgreich ausgeführt werden, gibt die Funktion einen Wert ungleich 0 zurück, ansonsten &#8211;1. Für den String <span class="clisting">kommandozeile</span> können Sie alles angeben, was auch in der Kommandozeile erlaubt ist.</p>
<p>Um zu testen, ob auf Ihrem System der Kommandozeilenprozessor überhaupt zur Verfügung steht, müssen Sie die Funktion <span class="clisting">system()</span> mit dem <span class="clisting">NULL</span>-Zeiger aufrufen:</p>
<div class="listing"><pre class="prettyprint">if(system(NULL) == 0) {
   // Kommandozeilenprozessor steht nicht zur Verfügung
}
else {
   // Kommandozeilenprozessor ist bereit
}</pre></div>
<p>Wird dabei ein Wert ungleich null zurückgegeben, können Sie die Funktion <span class="clisting">system()</span> ohne Bedenken verwenden.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellenkopf"><span class="cfett">Hinweis</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p class="BStandard">Wenn Sie sich mit der Linux-Systemprogrammierung ein wenig auskennen, dürfte Ihnen das Verhalten der Funktion <span class="clisting">system()</span> bekannt vorkommen. Mit der Funktion <span class="clisting">system()</span> werden <span class="clisting">fork()</span>, <span class="clisting">exec()</span> und <span class="clisting">waitpid()</span> praktisch auf einmal aufgerufen.</p>
</td>
</tr>
</table><br><p>Zum Abschluss folgt ein einfaches Beispiel zur Funktion <span class="clisting">system()</span>. Auf jedem System gibt es einen Kommandozeilenbefehl, mit dem sich das vollständige Verzeichnis auflisten lässt. Unter Linux/UNIX ist dies <span class="clisting">ls</span>, und unter Windows/MS-DOS heißt das Kommando <span class="clisting">dir</span>. Im folgenden Listing soll dieses Kommando auf dem jeweiligen System mithilfe der Funktion <span class="clisting">system()</span> ausgeführt werden.</p>
<div class="listing"><pre class="prettyprint">/* list_dir.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#ifdef __unix__
   #define KOMMANDO system("ls -C")
#else
   #define KOMMANDO system("dir /w")
#endif

int main(void) {
  if( system(NULL) == 0) {
     fprintf(stderr,"Kein Kommandozeilenprozessor vorhanden \n");
     return EXIT_FAILURE;
  }
  else
     KOMMANDO;
  return EXIT_SUCCESS;
}</pre></div><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellenkopf"><span class="cfett">Achtung</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p class="BStandard">Vermeiden Sie den <span class="clisting">system()</span>-Funktionsaufruf, mit dem sich der Anwender einen eigenen String zusammenbasteln kann. Böse Anwender könnten dabei so manchen gefährlichen Konsolenbefehl ausführen lassen.</p>
</td>
</tr>
</table><br><p>Nicht besprochen in diesem Abschnitt wurde die Funktion der Headerdatei <span class="ckursiv">&lt;stdlib.h&gt;</span>, mit der Sie Multi-Byte-Zeichen bearbeiten können, da diese recht selten benötigt wird.</p>
<p>Die Funktion <span class="clisting">getenv()</span>, mit der Sie Umgebungsvariablen auslesen können, wird in Kapitel 23, »CGI mit C«, besprochen.</p><br><hr><a name="kommentar"></a><h3>Ihr Kommentar</h3>
                       Wie hat Ihnen das &lt;openbook&gt; gefallen? Wir freuen uns immer über Ihre freundlichen und kritischen Rückmeldungen.
                       <!--<form action="http://www.galileo-press.de/feedback/openbook" method="post" style="text-align: center; margin-top: 10px;"><input type="hidden" name="openbookurl" value="http://openbook.galileocomputing.de/c_von_a_bis_z/020_c_headerdateien_004.htm"><input type="hidden" name="buchtitel" value="C von A bis Z"><input type="hidden" name="Kapitel" value="20.4 <stdlib.h>"><table border="0">
<tr>
<td><label for="name">Name</label><br></td>
<td><input type="text" name="name" id="name" size="40"><br></td>
</tr>
<tr>
<td><label for="email">E-Mail</label><br></td>
<td><input type="text" name="email" id="email" size="40"><br></td>
</tr>
<tr>
<td valign="top"><label for="comment">Ihr Kommentar</label><br></td>
<td><textarea name="comment" id="comment" rows="10" cols="40"></textarea><br></td>
</tr>
<tr>
<td>
</td>
<td><input type="submit" value="Kommentar absenden"></td>
</tr>
</table>
</form>--><a href="https://www.rheinwerk-verlag.de/feedback/produkt/2132/">>> Zum Feedback-Formular</a>
</div></td>
</tr>
</table></td>
</tr>
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a href="020_c_headerdateien_003.html" class="navnav"> &lt;&lt;   zurück</a></td>
<td width="49%"><div align="center"><a class="navnav" href="#">&lt;top&gt;</a></div></td>
<td align="right" width="25%"><div align="right"><a href="020_c_headerdateien_005.html" class="navnav">vor   &gt;&gt; </a></div></td>
</tr>
</table></td>
</tr>
</table>
</div></td>
<td width="10" valign="top">&nbsp;&nbsp;</td>
<td width="160" valign="top">
<table border="0" cellpadding="0" cellspacing="0" width="160">
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="tbl2" height="20" colspan="2">
&nbsp;<a href="https://www.rheinwerk-verlag.de/?GPP=opc3" class="nav">
<strong>Zum Katalog</strong></a>
</td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2">
<img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td><a href="https://www.rheinwerk-verlag.de/c-von-a-bis-z_2132/?GPP=opc3">
	<img src="common/1411.gif" width="117" height="167" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C von A bis Z" title="Zum Katalog: C von A bis Z">
<br /><br /><strong>&nbsp;C von A bis Z</strong><br /><img src="common/pfeil_rechts5.gif" border="0" alt="">Jetzt&nbsp;bestellen</a><br /><br />
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="tbl2" height="20" colspan="2"><a href="#kommentar" class="nav"><strong>&nbsp;Ihre Meinung?</strong></a>
</td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td>Wie hat Ihnen das &lt;openbook&gt; gefallen?<br /><a href="#kommentar"><img src="common/pfeil_rechts5.gif" border="0" alt="">Ihre Meinung</a>
<br /><br /></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="tbl2" height="20" colspan="2">&nbsp;<a href="https://www.rheinwerk-verlag.de/?GPP=opc3" class="nav"><strong>Buchtipps</strong></a></td>
</tr>
<tr> 
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="https://www.rheinwerk-verlag.de/cc_3536/?GPP=opc3">
<img src="common/2757.gif" width="69" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C/C++" title="Zum Katalog: C/C++"><br /><br /><br /><br /><br /><br /><br />&nbsp;C/C++</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="https://www.rheinwerk-verlag.de/einstieg-in-c_3557/?GPP=opc3">
<img src="common/2793.gif" width="74" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Einstieg in C" title="Zum Katalog: Einstieg in C"><br /><br /><br /><br /><br /><br /><br />&nbsp;Einstieg in C</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="https://www.rheinwerk-verlag.de/schrodinger-programmiert-c_2853/?GPP=opc3">
<img src="common/1756.gif" width="85" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Schrödinger programmiert C++" title="Zum Katalog: Schrödinger programmiert C++"><br /><br /><br /><br /><br /><br /><br />&nbsp;Schrödinger<br />&nbsp;programmiert C++</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="https://www.rheinwerk-verlag.de/c_3278/?GPP=opc3">
<img src="common/2021.gif" width="69" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C++ Handbuch" title="Zum Katalog: C++ Handbuch"><br /><br /><br /><br /><br /><br /><br />&nbsp;C++ Handbuch</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="https://www.rheinwerk-verlag.de/it-handbuch-fur-fachinformatiker_3329/?GPP=opc3">
<img src="common/2234.gif" width="78" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: IT-Handbuch für Fachinformatiker" title="Zum Katalog: IT-Handbuch für Fachinformatiker"><br /><br /><br /><br /><br /><br /><br />&nbsp;IT-Handbuch für<br />&nbsp;Fachinformatiker</a><br /><br /></td>
</tr>
</table></td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="tbl2" height="20" colspan="2"><strong>&nbsp;Shopping</strong></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td><b>Versandkostenfrei</b> bestellen in Deutschland und &Ouml;sterreich<br /><a href="https://www.rheinwerk-verlag.de/hilfe/bestellung_6?GPP=opc3"><img src="common/pfeil_rechts5.gif" border="0" alt="Info">Info</a><br /><br /></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table><br><br><hr width="70%" align="center">
<div align="center">
<p class="standard"><strong>Copyright © Rheinwerk Verlag GmbH 2009</strong><br>
        Für Ihren privaten Gebrauch dürfen Sie die Online-Version natürlich ausdrucken.
        Ansonsten unterliegt das &lt;openbook&gt; denselben Bestimmungen, wie die
        gebundene Ausgabe: Das Werk einschließlich aller seiner Teile ist urheberrechtlich
        geschützt. Alle Rechte vorbehalten einschließlich der Vervielfältigung, Übersetzung,
        Mikroverfilmung sowie Einspeicherung und Verarbeitung in elektronischen Systemen.</p><br><a href="https://www.rheinwerk-verlag.de/">[Rheinwerk Computing]</a><br><br>
      Rheinwerk Verlag GmbH, Rheinwerkallee 4, 53227 Bonn, Tel.: 0228.42150.0, Fax 0228.42150.77, <a href="mailto:service@rheinwerk-verlag.de">service@rheinwerk-verlag.de</a></div><br><br></body>

<!-- Mirrored from openbook.rheinwerk-verlag.de/c_von_a_bis_z/020_c_headerdateien_004.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 23 Jun 2017 19:48:06 GMT -->
</html>
