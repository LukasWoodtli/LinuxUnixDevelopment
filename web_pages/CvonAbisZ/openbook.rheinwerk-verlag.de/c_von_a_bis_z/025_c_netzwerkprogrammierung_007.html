<html>

<!-- Mirrored from openbook.rheinwerk-verlag.de/c_von_a_bis_z/025_c_netzwerkprogrammierung_007.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 23 Jun 2017 19:52:47 GMT -->
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Rheinwerk Computing :: C von A bis Z &ndash; 25.7 Cross-Plattform-Development</title>
<meta name="title" content="Rheinwerk Computing :: C von A bis Z - 25.7 Cross-Plattform-Development">
<meta name="author" content="J&uuml;rgen Wolf ">
<meta name="publisher" content="Rheinwerk Verlag GmbH 2009">
<meta name="copyright" content="Rheinwerk Verlag GmbH 2009">
<meta name="Description" content="C von A bis Z - Das umfassende Handbuch &ndash; 25.7 Cross-Plattform-Development">
<meta name="audience" content="Alle">
<meta name="robots" content="INDEX,FOLLOW">
<meta http-equiv="content-language" content="de">
<link rel="stylesheet" type="text/css" href="common/rw_open.css">
<link rel="prev" href="025_c_netzwerkprogrammierung_006.html">
<link rel="next" href="025_c_netzwerkprogrammierung_008.html"><script type="text/javascript"><!--
    function OpenWin(url,name,height,width)
    {
      var InfoWin = window.open(url,name,"directories=0,height="+height+",width=" + width + ",hotkeys=0,location=0,menubar=0,resizable=1,screenX=150,screenY=10,left=150,top=10,scrollbars=1,status=1,titlebar=0,toolbar=0");
      InfoWin.focus();
    }
    //--></script><link href="common/prettify.css" type="text/css" rel="stylesheet"><script type="text/javascript" src="common/prettify.js"></script></head>
<body vlink="#000099" link="#000099" alink="#000099" onload="prettyPrint()">
<table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#00549d">
<tr>
<td height="74" valign="bottom" colspan="2"><a href="https://www.rheinwerk-verlag.de/katalog/openbook?GPP=opc3"><img src="common/rw_openbook.gif" width="200" height="56" border="0" alt="Rheinwerk Computing < openbook >" title="Rheinwerk Computing < openbook >"></a></td>
<td width="80" height="74"><a href="https://www.rheinwerk-verlag.de/?GPP=opc3"><img src="common/rw_computing.gif" border="0" alt="Rheinwerk Computing - Professionelle Bücher. Auch für Einsteiger." title="Rheinwerk Computing - Professionelle Bücher. Auch für Einsteiger."></a></td>
</tr>
</table>
<div align="right"><a href="https://www.rheinwerk-verlag.de/?GPP=opc3" class="navnav">Professionelle Bücher. Auch für Einsteiger.</a></div><br><table class="tbl" border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="190" valign="top">
<table class="tbl1" border="0" cellpadding="3" cellspacing="0" width="190" align="left">
<tr>
<td class="tbl2"><a class="nav" href="index-2.html#_top">Inhaltsverzeichnis</a></td>
</tr>
<tr>
<td><a class="navnav" href="000_c_vorwort_001.html#mj764cb3fd439d3b95d1843e7c7d17f235">Vorwort</a></td>
</tr>
<tr>
<td><a class="navnav" href="000_c_vorwort_gutachter_001.html#mj3d41cb339c9b2fc1d6e99cdaa93c3860">Vorwort des Gutachters</a></td>
</tr>
<tr>
<td><a class="navnav" href="001_c_einstieg_in_c_001.html#mja24d93ff97bb42dbebf4689160c45195">1 Einstieg in C</a></td>
</tr>
<tr>
<td><a class="navnav" href="002_c_das_erste_programm_001.html#mj2604a667cc98d3fa2178751273346b91">2 Das erste Programm</a></td>
</tr>
<tr>
<td><a class="navnav" href="003_c_grundlagen_001.html#mj7ac54ba315b94149806c1de3fc89ee7f">3 Grundlagen</a></td>
</tr>
<tr>
<td><a class="navnav" href="004_c_ein_ausgabe_001.html#mj20c131820fbfb1497afd796ee443599e">4 Formatierte Ein-/Ausgabe mit »scanf()« und »printf()«</a></td>
</tr>
<tr>
<td><a class="navnav" href="005_c_basisdatentypen_001.html#mjeda2957449ddc812dad62b400fe57752">5 Basisdatentypen</a></td>
</tr>
<tr>
<td><a class="navnav" href="006_c_operatoren_001.html#mjab3693b096d581607801a36ce88905fc">6 Operatoren</a></td>
</tr>
<tr>
<td><a class="navnav" href="007_c_typumwandlung_001.html#mj5c5e497ac2ab4367fe9df0ffd218cfca">7 Typumwandlung</a></td>
</tr>
<tr>
<td><a class="navnav" href="008_c_kontrollstrukturen_001.html#mjc7bf6f584a2fe20b4c5f6b16ba15d57d">8 Kontrollstrukturen</a></td>
</tr>
<tr>
<td><a class="navnav" href="009_c_funktionen_001.html#mj7893101be51aa469fe52334038acd465">9 Funktionen</a></td>
</tr>
<tr>
<td><a class="navnav" href="010_c_praeprozessor_001.html#mjacdd200a20163a4d3fa418b6cb95763e">10 Präprozessor-Direktiven</a></td>
</tr>
<tr>
<td><a class="navnav" href="011_c_arrays_001.html#mje29de26c54a3884f7316cbbb2a073ad8">11 Arrays</a></td>
</tr>
<tr>
<td><a class="navnav" href="012_c_zeiger_001.html#mjee28a882ef9125d2c4cc49121b2c65c1">12 Zeiger (Pointer)</a></td>
</tr>
<tr>
<td><a class="navnav" href="013_c_kommandozeilenargumente_001.html#mjf6a9e42fa3bc25b2b1e06270e7bf8f68">13 Kommandozeilenargumente</a></td>
</tr>
<tr>
<td><a class="navnav" href="014_c_dyn_speicherverwaltung_001.html#mj8d062301d2449b13710f1484d499cd9b">14 Dynamische Speicherverwaltung</a></td>
</tr>
<tr>
<td><a class="navnav" href="015_c_strukturen_001.html#mj5e146ba18168113a5c645cd2d07c4ec8">15 Strukturen</a></td>
</tr>
<tr>
<td><a class="navnav" href="016_c_ein_ausgabe_funktionen_001.html#mj136f9ac6b5b7c440aafe5010411ef011">16 Ein-/Ausgabe-Funktionen</a></td>
</tr>
<tr>
<td><a class="navnav" href="017_c_dateien_verzeichnisse_001.html#mj9f81aea722a9edb8d0080df81eb9402c">17 Attribute von Dateien und das Arbeiten mit Verzeichnissen (nicht ANSI C)</a></td>
</tr>
<tr>
<td><a class="navnav" href="018_c_stdarg_h_001.html#mj9d64febdc46a1375e5c4498b17154e30">18 Arbeiten mit variabel langen Argumentlisten &#8211; &lt;stdarg.h&gt;</a></td>
</tr>
<tr>
<td><a class="navnav" href="019_c_zeitroutinen_001.html#mj0a8102e96a1297bd767ac7274e069f0f">19 Zeitroutinen</a></td>
</tr>
<tr>
<td><a class="navnav" href="020_c_headerdateien_001.html#mjf3caede8ebd504dc6b7454b297c251e8">20 Weitere Headerdateien und ihre Funktionen (ANSI C)</a></td>
</tr>
<tr>
<td><a class="navnav" href="021_c_dyn_datenstrukturen_001.html#mja75ba2f4ab8f95e9e321d195c1e26d76">21 Dynamische Datenstrukturen</a></td>
</tr>
<tr>
<td><a class="navnav" href="022_c_algorithmen_001.html#mj07afe6f332eab2e8168da2f69f7b31c4">22 Algorithmen</a></td>
</tr>
<tr>
<td><a class="navnav" href="023_c_cgi_001.html#mj6c4219b4e615fa24deaa57d5c3d04db8">23 CGI mit C</a></td>
</tr>
<tr>
<td><a class="navnav" href="024_c_mysql_001.html#mj12dab301033f9fd856aa739270c45e08">24 MySQL und C</a></td>
</tr>
<tr>
<td><a class="navh" href="##mja8101c6e0e4cb2e6fd8312114dad30d7">25 Netzwerkprogrammierung und Cross&ndash;Plattform-Entwicklung</a></td>
</tr>
<tr>
<td><a class="navnav" href="026_c_paralleles_rechnen_001.html#mj710dc0ad851d57e60533f8797ff9c1e6">26 Paralleles Rechnen</a></td>
</tr>
<tr>
<td><a class="navnav" href="027_c_sicheres_programmieren_001.html#mj13eba8f9d68ac8414bffaa3a1b24ec31">27 Sicheres Programmieren</a></td>
</tr>
<tr>
<td><a class="navnav" href="028_c_weiterfuehrendes_001.html#mj3e65f750149ade087925f303b3871af9">28 Wie geht&#8217;s jetzt weiter?</a></td>
</tr>
<tr>
<td><a class="navnav" href="029_c_anhang_a_001.html#mjec9bf1c5e3fe2e46047c2f9c7aa9c531">A Operatoren</a></td>
</tr>
<tr>
<td><a class="navnav" href="030_c_anhang_b_001.html#mj803443bb6e7546011c48e6e57fbdbb64">B Die C-Standard-Bibliothek</a></td>
</tr>
<tr>
<td><a class="navnav" href="stichwort.html#_top">Stichwort</a></td>
</tr>
<!--<tr>
<td><br><a href="http://download.galileo-press.de/openbook/c_von_a_bis_z/galileocomputing_c_von_a_bis_z.zip" class="navnav"><strong>Download:</strong><br>- ZIP, ca. 10,3 MB</a></td>
</tr>-->
<tr>
<td><br><a href="https://www.rheinwerk-verlag.de/2132/?GPP=opc3" class="navnav">Buch bestellen</a></td>
</tr>
<tr>
<td><a class="navnav" href="#kommentar">Ihre Meinung?</a><br><br></td>
</tr>
</table>
</td>
<td width="10"><img src="common/spacer10.gif" width="10" height="10" alt="Spacer"></td>
<td width="85%" valign="top" align="center"><div align="center">
<table width="98%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a href="025_c_netzwerkprogrammierung_006.html" class="navnav"> &lt;&lt;   zurück</a></td>
<td width="49%"><div align="center"><a href="https://www.rheinwerk-verlag.de/?GPP=opc3" class="navnav">Rheinwerk Computing</a> / <a href="https://www.rheinwerk-verlag.de/openbook/?GPP=opc3" class="navnav">&lt;openbook&gt;</a> / <a href="index-2.html" class="navnav"> C von A bis Z</a></div></td>
<td align="right" width="25%"><div align="right"><a href="025_c_netzwerkprogrammierung_008.html" class="navnav">vor   &gt;&gt; </a></div></td>
</tr>
</table></td>
</tr>
<tr>
<td width="100%" valign="top"><table width="100%" border="0" cellpadding="10" cellspacing="0" class="box">
<tr>
<td colspan="2"><a href="https://www.rheinwerk-verlag.de/2132/?GPP=opc3" class="buchtitel">C von A bis Z</a><span class="autor"> von J&uuml;rgen Wolf </span><br><span class="untertitel">Das umfassende Handbuch</span></td>
</tr>
<tr>
<td valign="top" width="211"><dl>
<dt><a href="https://www.rheinwerk-verlag.de/2132/?GPP=opc3" class="navnav"><img src="common/9783836214117.gif" border="0" alt="Buch: C von A bis Z" title="Buch: C von A bis Z"></a></dt>
<dd><br><a href="https://www.rheinwerk-verlag.de/2132/?GPP=opc3"><span class="autor"><strong>C von A bis Z</strong><br>3., aktualisierte und erweiterte Auflage, geb., mit CD und Referenzkarte<br>1.190 S., 39,90 Euro<br>Rheinwerk Computing<br>ISBN 978-3-8362-1411-7</span></a></dd>
</dl></td>
<td width="80%"><table border="0">
<tr>
<td valign="baseline"><img src="common/pfeil_u.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="3" class="kap"><strong><a href="025_c_netzwerkprogrammierung_001.html#mja8101c6e0e4cb2e6fd8312114dad30d7" class="navnav">25 Netzwerkprogrammierung und Cross&ndash;Plattform-Entwicklung</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="025_c_netzwerkprogrammierung_001.html#mj90de6127e49e7b6bbf3d89d2ba8c8311" class="navnav">25.1 Begriffe zur Netzwerktechnik</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="025_c_netzwerkprogrammierung_001.html#mjbf2a43d33b65132a43d19f18645a3507" class="navnav">25.1.1 IP-Nummern</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="025_c_netzwerkprogrammierung_001.html#mj5f404eca9c0d01debd902d009585193b" class="navnav">25.1.2 Portnummer</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="025_c_netzwerkprogrammierung_001.html#mjacd6910a47d8022594b0fa597b9ab3f8" class="navnav">25.1.3 Host- und Domainname</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="025_c_netzwerkprogrammierung_001.html#mje65054add809c82a6c3835129f775889" class="navnav">25.1.4 Nameserver</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="025_c_netzwerkprogrammierung_001.html#mj4220478b4296d3c39447a3258cefcaa9" class="navnav">25.1.5 Das IP-Protokoll</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="025_c_netzwerkprogrammierung_001.html#mj81ee096acc1c9718166ee6876ceac786" class="navnav">25.1.6 TCP und UDP</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="025_c_netzwerkprogrammierung_001.html#mj026dcf95963c30f3a232837965a8e774" class="navnav">25.1.7 Was sind Sockets?</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="025_c_netzwerkprogrammierung_002.html#mj1c3afaad9741d42436f997cb72c62d4e" class="navnav">25.2 Headerdateien zur Socketprogrammierung</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="025_c_netzwerkprogrammierung_002.html#mje3ed53b4dbcbe6752d398d3bef9762f5" class="navnav">25.2.1 Linux/UNIX</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="025_c_netzwerkprogrammierung_002.html#mj73f2f72802f98899435ecc1c087b5cee" class="navnav">25.2.2 Windows</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="025_c_netzwerkprogrammierung_003.html#mj165406658863029e1d323d48020e3444" class="navnav">25.3 Client/Server-Prinzip</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="025_c_netzwerkprogrammierung_003.html#mj051ed7a117c7e015544542655c23de33" class="navnav">25.3.1 Loopback-Interface</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="025_c_netzwerkprogrammierung_004.html#mj50a66f07dc78c522bbc8a31b18c366a8" class="navnav">25.4 Erstellen einer Client-Anwendung</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="025_c_netzwerkprogrammierung_004.html#mjc55073cb49f2137a6fe9e8565b3f2df6" class="navnav">25.4.1 »socket()« &#8211; Erzeugen eines Kommunikationsendpunktes</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="025_c_netzwerkprogrammierung_004.html#mj05b1cb6b5680838f16cd08f6544f03e9" class="navnav">25.4.2 »connect()« &#8211; ein Client stellt eine Verbindung zum Server her</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="025_c_netzwerkprogrammierung_004.html#mjcc31996af428746674c11b815d3e100b" class="navnav">25.4.3 Senden und Empfangen von Daten</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="025_c_netzwerkprogrammierung_004.html#mjc31a705e5811e09dd9d17f20f650bef9" class="navnav">25.4.4 »close()« und »closesocket()«</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="025_c_netzwerkprogrammierung_005.html#mj80e21e66b25fefd05e8c817719845013" class="navnav">25.5 Erstellen einer Server-Anwendung</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="025_c_netzwerkprogrammierung_005.html#mj307c4be8bd53a079d3dfa9958ca909b0" class="navnav">25.5.1 »bind()« &#8211; Festlegen einer Adresse aus dem Namensraum</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="025_c_netzwerkprogrammierung_005.html#mjeab44080a7c8523d7051d181f2d90a21" class="navnav">25.5.2 »listen()« &#8211; Warteschlange für eingehende Verbindungen einrichten</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="025_c_netzwerkprogrammierung_005.html#mj23be1797e05d9762113481d3bf7872b7" class="navnav">25.5.3 »accept()« und die Serverhauptschleife</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="025_c_netzwerkprogrammierung_006.html#mj39436063fa2ddeff09ac910424931c53" class="navnav">25.6 (Cross-Plattform-)TCP-Echo-Server</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="025_c_netzwerkprogrammierung_006.html#mjf73c5c0852491723ed716d490ad51fcf" class="navnav">25.6.1 Der Client</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="025_c_netzwerkprogrammierung_006.html#mj1a65237c3c8e0b3f4f1ec13fa9f7690e" class="navnav">25.6.2 Der Server</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="#mj4324a356c575e91bca60629c2b27804d" class="navh">25.7 Cross-Plattform-Development</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjf581cbe47f1669ef59195b50a73e8d27" class="navh">25.7.1 Abstraction Layer</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj4d9516b91278b259d2de1a0067a197a7" class="navh">25.7.2 Headerdatei für Linux/UNIX</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjaa263193e09f067a442b7e85c2dcee63" class="navh">25.7.3 Linux/UNIX-Quellcodedatei</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj1bcde194346542bdd880f32877b8509e" class="navh">25.7.4 Headerdatei für MS-Windows</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mjfd336749a2559387be148a4f62593234" class="navh">25.7.5 Windows-Quellcodedatei</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj22ace026a589e96367846d8d2f148ed2" class="navh">25.7.6 All together &#8211; die »main«-Funktionen</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mj111a55df67b579f4ca5d1646d87861f6" class="navh">25.7.7 Ein UDP-Beispiel</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="#mje2ffcc22df9d40b6c9fc2747f25ddd89" class="navh">25.7.8 Mehrere Clients gleichzeitig behandeln</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline" colspan="2"><strong><a href="025_c_netzwerkprogrammierung_008.html#mje4f5e780930470d69864797cba7f848d" class="navnav">25.8 Weitere Anmerkungen zur Netzwerkprogrammierung</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="025_c_netzwerkprogrammierung_008.html#mjc2f15fd49c3c1bdbf5dcc2e468f4a50a" class="navnav">25.8.1 Das Datenformat</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="025_c_netzwerkprogrammierung_008.html#mj30ec737d34e86c30e7c368515d30d480" class="navnav">25.8.2 Der Puffer</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="025_c_netzwerkprogrammierung_008.html#mjaa0377d23e112fac5fc45456d8e8c5cf" class="navnav">25.8.3 Portabilität</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="025_c_netzwerkprogrammierung_008.html#mj46218b64e64226323710c041737ff1a5" class="navnav">25.8.4 Von IPv4 nach IPv6</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="025_c_netzwerkprogrammierung_008.html#mjca1db97f014ce88515371d38ad53319d" class="navnav">25.8.5 RFC-Dokumente (Request for Comments)</a></strong></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="Pfeil"></td>
<td valign="baseline"><strong><a href="025_c_netzwerkprogrammierung_008.html#mj99c9507713d25e0c8c61aa14fe9acb32" class="navnav">25.8.6 Sicherheit</a></strong></td>
</tr>
</table><br></td>
</tr>
</table>
<table width="100%" cellpadding="20" cellspacing="0" border="0" bgcolor="#eeeeee">
<tr>
<td><div class="main"><a id="mj4324a356c575e91bca60629c2b27804d" name="mj4324a356c575e91bca60629c2b27804d"></a><a name="t21"></a><a name="t2t31"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div>
<h2 class="t2"><span class="cfett">25.7</span><span class="cfett"> Cross-Plattform-Development</span>  <a href="#t2t32"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><img src="common/15x15leer.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></h2>
<p>Das kleine Beispiel des TCP-Echo-Servers zeigte Ihnen einen einfachen Weg, wie Sie mit einfachen <span class="clisting">#ifdef</span>-Präprozessor-Direktiven eine Cross-Plattform-Anwendung schreiben können. Das Problem dabei (am Quellcode) war allerdings, dass alles für jede Plattform in eine Datei geschrieben wurde. Für das kleine Programm ist das zwar nicht die Rede wert, aber bei umfangreicheren und komplizierten Programmen ist es sinnvoller, einen abstrakten Layer (<span class="ckursiv">Abstraction Layer</span>) zu schreiben. Nicht anders wird dies übrigens bei solchen Mammut-Projekten wie MySQL und dem Apache realisiert &#8211; auch hier finden Sie für alle gängigen Plattformen eine extra Version.</p><a id="mjf581cbe47f1669ef59195b50a73e8d27" name="mjf581cbe47f1669ef59195b50a73e8d27"></a><a name="t31"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div><a name="t2t32"></a><h3 class="t3"><span class="cfett">25.7.1</span><span class="cfett"> Abstraction Layer</span>  <a href="#t2t33"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t31"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Hinter dem Begriff <span class="ckursiv">Abstraction Layer</span> verbirgt sich nichts Kompliziertes. Der Abstraction Layer isoliert plattformspezifische Funktionen und Datentypen in separate Module für portablen Code. Die plattformspezifischen Module werden dann speziell für jede Plattform geschrieben. Des Weiteren erstellen Sie eine neue Headerdatei, in der sich eventuell die plattformspezifischen <span class="clisting">typedef</span> und <span class="clisting">#define</span> mitsamt den Funktionsprototypen der Module befinden. Bei der Anwendung selbst binden Sie nur noch diese Headerdatei ein. Auf den folgenden Seiten finden Sie nun die einzelnen Quellcodes für unseren abstrakten Layer &#8211; ich werde diesen einfach SOCKETPRX nennen.</p><a id="mj4d9516b91278b259d2de1a0067a197a7" name="mj4d9516b91278b259d2de1a0067a197a7"></a><a name="t32"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div><a name="t2t33"></a><h3 class="t3"><span class="cfett">25.7.2</span><span class="cfett"> Headerdatei für Linux/UNIX</span>  <a href="#t2t34"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t32"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<div class="listing"><pre class="prettyprint">/* socketprx.h für Linux/UNIX */
#ifndef SOCKETPRX_H_
#define SOCKETPRX_H_

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;

/* ein eigener primitver Datentyp für den Socket-Deskriptor */
#define socket_t int
/* Funktionsprototypen */
void error_exit(char *error_message);
int create_socket( int af, int type, int protocol );
void bind_socket(socket_t
  *sock, unsigned long adress, unsigned short port);
void listen_socket( socket_t *sock );
void accept_socket( socket_t *new_socket, socket_t *socket );
void connect_socket(socket_t *sock, char *serv_addr,
 unsigned short port);
void TCP_send( socket_t *sock, char *data, size_t size);
void TCP_recv( socket_t *sock, char *data, size_t size);
void UDP_send ( socket_t *sock, char *data, size_t size,
  char *addr, unsigned short port);
void UDP_recv( socket_t *sock, char *data, size_t size);
void close_socket( socket_t *sock );
void cleanup(void);

#endif</pre></div><a id="mjaa263193e09f067a442b7e85c2dcee63" name="mjaa263193e09f067a442b7e85c2dcee63"></a><a name="t33"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div><a name="t2t34"></a><h3 class="t3"><span class="cfett">25.7.3</span><span class="cfett"> Linux/UNIX-Quellcodedatei</span>  <a href="#t2t35"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t33"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<div class="listing"><pre class="prettyprint">/* socketlayer.c - für Linux/UNIX */
#include  "socketprx.h"

/* Die Funktion gibt aufgetretene Fehler aus und
 * beendet die Anwendung. */
void error_exit(char *error_message) {
    fprintf(stderr, "%s: %s\n", error_message, strerror(errno));
    exit(EXIT_FAILURE);
}

 int create_socket( int af, int type, int protocol ) {
    socket_t sock;
    const int y = 1;
    /* Erzeuge das Socket. */
    sock = socket(af, type, protocol);
    if (sock &lt; 0)
        error_exit("Fehler beim Anlegen eines Sockets");

    /* Mehr dazu siehe Anmerkung am Ende des Listings ... */
    setsockopt( sock, SOL_SOCKET,
                SO_REUSEADDR, &amp;y, sizeof(int));
    return sock;
}

/* Erzeugt die Bindung an die Serveradresse,
 * (genauer gesagt an einen bestimmten Port). */
void bind_socket(socket_t *sock, unsigned long adress,
                 unsigned short port) {
   struct sockaddr_in server;
   memset( &amp;server, 0, sizeof (server));
   server.sin_family = AF_INET;
   server.sin_addr.s_addr = htonl(adress);
   server.sin_port = htons(port);
   if (bind(*sock, (struct sockaddr*)&amp;server,sizeof(server)) &lt; 0)
       error_exit("Kann das Socket nicht \"binden\"");
}

/* Teile dem Socket mit, dass Verbindungswünsche
 * von Clients entgegengenommen werden. */
void listen_socket( socket_t *sock ) {
  if(listen(*sock, 5) == -1 )
      error_exit("Fehler bei listen");
}

/* Bearbeite die Verbindungswünsche von Clients.
 * Der Aufruf von accept() blockiert so lange,
 * bis ein Client Verbindung aufnimmt. */
void accept_socket( socket_t *socket, socket_t *new_socket ){
   struct sockaddr_in client;
   unsigned int len;

   len = sizeof(client);
   *new_socket=accept(*socket,(struct sockaddr *)&amp;client, &amp;len);
   if (*new_socket  == -1)
      error_exit("Fehler bei accept");
}

/* Baut die Verbindung zum Server auf. */
void connect_socket(socket_t *sock, char *serv_addr,
                    unsigned short port) {
   struct sockaddr_in server;
   struct hostent *host_info;
   unsigned long addr;

   memset( &amp;server, 0, sizeof (server));
   if ((addr = inet_addr( serv_addr )) != INADDR_NONE) {
       /* argv[1] ist eine numerische IP-Adresse */
       memcpy( (char *)&amp;server.sin_addr, &amp;addr, sizeof(addr));
   }
   else {
       /* Für den Fall der Fälle: Wandle den
        * Servernamen bspw. "localhost" in eine IP-Adresse um. */
       host_info = gethostbyname( serv_addr );
       if (NULL == host_info)
           error_exit("Unbekannter Server");
       memcpy( (char *)&amp;server.sin_addr, host_info-&gt;h_addr,
               host_info-&gt;h_length);
   }
   server.sin_family = AF_INET;
   server.sin_port = htons( port );
   /* Baue die Verbindung zum Server auf. */
   if (connect(
         *sock, (struct sockaddr *)&amp;server, sizeof( server)) &lt; 0)
      error_exit( "Kann keine Verbindung zum Server herstellen");
}

/* Daten versenden via TCP */
void TCP_send( socket_t *sock, char *data, size_t size) {
   if(send( *sock, data, size, 0) == -1 )
      error_exit("Fehler bei send()");
}

/* Daten empfangen via TCP */
void TCP_recv( socket_t *sock, char *data, size_t size) {
    unsigned int len;
    len = recv (*sock, data, size, 0);
    if( len &gt; 0 || len != -1 )
       data[len] = '\0';
    else
       error_exit("Fehler bei recv()");
}

/* Daten senden via UDP */
void UDP_send ( socket_t *sock, char *data, size_t size,
                char *addr, unsigned short port){
  struct sockaddr_in addr_sento;
  struct hostent *h;
  int rc;

  /* IP-Adresse des Servers überprüfen */
  h = gethostbyname(addr);
  if (h == NULL)
     error_exit("Unbekannter Host?");

  addr_sento.sin_family = h-&gt;h_addrtype;
  memcpy ( (char *) &amp;addr_sento.sin_addr.s_addr,
           h-&gt;h_addr_list[0], h-&gt;h_length);
  addr_sento.sin_port = htons (port);

  rc = sendto(*sock, data, size, 0,
                 (struct sockaddr *) &amp;addr_sento,
                 sizeof (addr_sento));
  if (rc &lt; 0)
     error_exit("Konnte Daten nicht senden - sendto()");
}

/* Daten empfangen via UDP */
void UDP_recv( socket_t *sock, char *data, size_t size){
   struct sockaddr_in addr_recvfrom;
   unsigned int len;
   int n;

   len = sizeof (addr_recvfrom);
   n = recvfrom ( *sock, data, size, 0,
                   (struct sockaddr *) &amp;addr_recvfrom, &amp;len );
   if (n &lt; 0) {
       printf ("Keine Daten empfangen ...\n");
       return;
    }
}

/* Socket schließen */
void close_socket( socket_t *sock ){
    close(*sock);
}

/* Unter Linux/UNIX ist nichts zu tun ... */
void cleanup(void){
   printf("Aufraeumarbeiten erledigt ...\n");
   return;
}</pre></div><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellenkopf"><span class="cfett">Hinweis</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p class="BStandard">In diesem Beispiel zu Linux/UNIX wurde die Funktion <span class="clisting">setsockopt()</span> verwendet. Durch die Verwendung der symbolischen Konstante <span class="clisting">SO_REUSEADDR</span> stellen Sie das Socket so ein, damit es erlaubt ist, dass mehrere Prozesse (Clients) denselben Port teilen &#8211; sprich: Mehrere Clients können innerhalb kürzester Zeit mit dem Server in Verbindung treten. Außerdem lösen Sie damit auch das Problem, dass der Server beim Neustart seinen lokalen Port erst nach zwei Minuten Wartezeit wieder benutzen kann.</p>
</td>
</tr>
</table><br><a id="mj1bcde194346542bdd880f32877b8509e" name="mj1bcde194346542bdd880f32877b8509e"></a><a name="t34"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div><a name="t2t35"></a><h3 class="t3"><span class="cfett">25.7.4</span><span class="cfett"> Headerdatei für MS-Windows</span>  <a href="#t2t36"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t34"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<div class="listing"><pre class="prettyprint">/* socketprx.h für MS-Windows */
#ifndef SOCKETPRX_H_
#define SOCKETPRX_H_

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;winsock.h&gt;
#include &lt;io.h&gt;

#define socket_t SOCKET

void error_exit(char *error_message);
int create_socket( int af, int type, int protocol );
void bind_socket(socket_t *sock, unsigned long adress,
  unsigned short port);
void listen_socket( socket_t *sock );
void accept_socket( socket_t *new_socket, socket_t *socket );
void connect_socket(socket_t *sock, char *serv_addr,
  unsigned short port);
void TCP_send( socket_t *sock, char *data, size_t size);
void TCP_recv( socket_t *sock, char *data, size_t size);
void UDP_send (socket_t *sock, char *data, size_t size);
void UDP_recv( socket_t *sock, char *data, size_t size,
  char *addr, unsigned short port);
void close_socket( socket_t *sock );
void cleanup(void);

#endif</pre></div><a id="mjfd336749a2559387be148a4f62593234" name="mjfd336749a2559387be148a4f62593234"></a><a name="t35"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div><a name="t2t36"></a><h3 class="t3"><span class="cfett">25.7.5</span><span class="cfett"> Windows-Quellcodedatei</span>  <a href="#t2t37"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t35"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<div class="listing"><pre class="prettyprint">/* socketlayer.c - für MS-Windows */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;winsock.h&gt;
#include &lt;io.h&gt;
#define socket_t SOCKET

/* Die Funktion gibt aufgetretene Fehler aus und
 * beendet die Anwendung. */
void error_exit(char *error_message) {
    fprintf(stderr,"%s: %d\n", error_message, WSAGetLastError());

    exit(EXIT_FAILURE);
}

/* Initialisiere TCP für Windows ("winsock"),
 * legt ein Socket an
 * und gibt das Socket als Rückgabewert zurück. */
int create_socket( int af, int type, int protocol ) {
    socket_t sock;
    WORD wVersionRequested;
    WSADATA wsaData;
    wVersionRequested = MAKEWORD (1, 1);
    if (WSAStartup (wVersionRequested, &amp;wsaData) != 0)
        error_exit( "Fehler beim Initialisieren von Winsock");
    else
        printf("Winsock initialisiert\n");

    /* Erzeuge das Socket. */
    sock = socket(af, type, protocol);
    if (sock &lt; 0)
        error_exit("Fehler beim Anlegen eines Sockets");
    return sock;
}

/* Erzeugt die Bindung an die Serveradresse
 * (genauer gesagt an einen bestimmten Port). */
void bind_socket(socket_t *sock, unsigned long adress,
                 unsigned short port) {
   struct sockaddr_in server;

   memset( &amp;server, 0, sizeof (server));
   server.sin_family = AF_INET;
   server.sin_addr.s_addr = htonl(adress);
   server.sin_port = htons(port);
   if (bind(*sock, (struct sockaddr*) &amp;server,
          sizeof( server)) == SOCKET_ERROR)
       error_exit("Kann das Socket nicht \"binden\"");
}

/* Teile dem Socket mit, dass Verbindungswünsche
 * von Clients entgegengenommen werden. */
void listen_socket( socket_t *sock ) {
  if(listen(*sock, 5) == -1 )
      error_exit("Fehler bei listen");
}

/* Bearbeite die Verbindungswünsche von Clients.
 * Der Aufruf von accept() blockiert so lange,
 * bis ein Client Verbindung aufnimmt. */
void accept_socket( socket_t *socket, socket_t *new_socket ){
   struct sockaddr_in client;
   unsigned int len;

   len = sizeof(client);
   *new_socket=accept(*socket, (struct sockaddr *)&amp;client, &amp;len);
   if (*new_socket == INVALID_SOCKET)
      error_exit("Fehler bei accept");
}

/* Baut die Verbindung zum Server auf. */
void connect_socket( socket_t *sock, char *serv_addr,
                     unsigned short port) {
   struct sockaddr_in server;
   struct hostent *host_info;
   unsigned long addr;

   memset( &amp;server, 0, sizeof (server));
   if ((addr = inet_addr( serv_addr )) != INADDR_NONE) {
       /* argv[1] ist eine numerische IP-Adresse. */
       memcpy( (char *)&amp;server.sin_addr, &amp;addr, sizeof(addr));
   }
   else {
       /* Für den Fall der Fälle: Wandle den
        * Servernamen bspw. "localhost" in eine IP-Adresse um. */
       host_info = gethostbyname( serv_addr );
       if (NULL == host_info)
           error_exit("Unbekannter Server");
       memcpy( (char *)&amp;server.sin_addr, host_info-&gt;h_addr,
                host_info-&gt;h_length);
   }
   server.sin_family = AF_INET;
   server.sin_port = htons( port );

   /* Baue die Verbindung zum Server auf. */
   if (connect(
         *sock, (struct sockaddr*)&amp;server, sizeof( server)) &lt; 0)
      error_exit( "Kann keine Verbindung zum Server herstellen");
}

/* Daten versenden via TCP */
void TCP_send( socket_t *sock, char *data, size_t size ) {
   if( send (*sock, data, size, 0) == SOCKET_ERROR )
      error_exit("Fehler bei send()");
}

/* Daten empfangen via TCP */
void TCP_recv( socket_t *sock, char *data, size_t size) {
    int len;
    len = recv (*sock, data, size, 0);
    if( len &gt; 0 || len != SOCKET_ERROR )
       data[len] = '\0';
    else
       error_exit("Fehler bei recv()");
}

/* Daten senden via UDP */
void UDP_send ( socket_t *sock, char *data, size_t size,
                char *addr, unsigned short port){
  struct sockaddr_in addr_sento;
  struct hostent *h;
  int rc;

  /* IP-Adresse vom Server überprüfen */
  h = gethostbyname(addr);
  if (h == NULL)
     error_exit("Unbekannter Host?");

  addr_sento.sin_family = h-&gt;h_addrtype;
  memcpy ( (char *) &amp;addr_sento.sin_addr.s_addr,
           h-&gt;h_addr_list[0], h-&gt;h_length);
  addr_sento.sin_port = htons (port);

  rc = sendto(*sock, data, size, 0,
                 (struct sockaddr *) &amp;addr_sento,
                 sizeof (addr_sento));
  if (rc == SOCKET_ERROR)
     error_exit("Konnte Daten nicht senden - sendto()");
}

/* Daten empfangen via UDP */
void UDP_recv( socket_t *sock, char *data, size_t size){
   struct sockaddr_in addr_recvfrom;
   unsigned int len;
   int n;


   len = sizeof (addr_recvfrom);
   n = recvfrom ( *sock, data, size, 0,
                   (struct sockaddr *) &amp;addr_recvfrom, &amp;len );
   if (n == SOCKET_ERROR)
      error_exit("Fehler bei recvfrom()");
}

/* Socket schließen und Winsock freigeben */
void close_socket( socket_t *sock ){
    closesocket(*sock);
}

void cleanup(void){
   /* Cleanup Winsock */
   WSACleanup();
   printf("Aufraeuumarbeiten erledigt ...\n");
}</pre></div><a id="mj22ace026a589e96367846d8d2f148ed2" name="mj22ace026a589e96367846d8d2f148ed2"></a><a name="t36"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div><a name="t2t37"></a><h3 class="t3"><span class="cfett">25.7.6</span><span class="cfett"> All together &#8211; die »main«-Funktionen</span>  <a href="#t2t38"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t36"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Nachdem Ihnen nun zwei Versionen von SOCKETPRX zur Verfügung stehen, können Sie die Module jetzt auf dem System Ihrer Wahl übersetzen und ausführen. Der Vorteil ist, dass Sie nur noch eine Hauptfunktion benötigen &#8211; alle plattformspezifischen Eigenheiten verstecken sich ja nun hinter dem Layer. Und es gibt noch einen weiteren Vorteil: Bei einer guten Planung des Layers gestaltet sich die Erstellung der <span class="clisting">main()</span>-Funktion erheblich leichter und kürzer &#8211; da Sie die Fehlerüberprüfungen nun auch dem Layer überlassen können. Besonders bezahlt macht sich ein solcher Layer, wenn Sie einzelne Routinen immer wieder benötigen. Somit können Sie eine tolle und simple Cross-Plattform-Bibliothek anbieten.</p>
<h4 class="t4"><span class="cfett">Der Server</span></h4>
<p>Das Beispiel des TCP-Echo-Servers wurde hier erweitert. Daraus ist nun eine Art 1:1-Chat zwischen dem Server und Client geworden (wie Sie mehr als einen Client bearbeiten können, erfahren Sie noch). Der Server »lauscht« am Port 15000 und wartet, bis ein Client mit diesem in Verbindung tritt. Sobald ein Client eine Verbindung zum Server hergestellt hat, können Sie (der Server) dem Client eine Zeichenkette als Nachricht senden. Anschließend wartet der Server auf eine Antwort vom Client. Sendet der Client dem Server die Textfolge »quit«, so bedeutet dies für den Server, dass der Client »aufgelegt« hat, und der Server wartet wieder (mittels <span class="clisting">accept()</span>) auf eine Verbindungsanfrage eines Clients. Der Quellcode des Servers sieht so aus:</p>
<div class="listing"><pre class="prettyprint">/* server.c */
#include &lt;string.h&gt;
#include "socketprx.h"
#define BUF 1024

int main (void) {
  socket_t sock1, sock2;
  int addrlen;
  char *buffer = (char*) malloc (BUF);

  sock1 = create_socket(AF_INET, SOCK_STREAM, 0);
  atexit(cleanup);
  bind_socket( &amp;sock1, INADDR_ANY, 15000 );
  listen_socket (&amp;sock1);
  addrlen = sizeof (struct sockaddr_in);

  while (1) {
     accept_socket( &amp;sock1, &amp;sock2 );
     do {
        printf ("Nachricht zum Versenden: ");
        fgets (buffer, BUF, stdin);
        TCP_send (&amp;sock2, buffer, strlen (buffer));
        TCP_recv (&amp;sock2, buffer, BUF-1);
        printf ("Nachricht empfangen: %s\n", buffer);
     } while (strcmp (buffer, "quit\n") != 0);
     close_socket (&amp;sock2);
  }
  close_socket (&amp;sock1);
  return EXIT_SUCCESS;
}</pre></div>
<h4 class="t4"><span class="cfett">Der Client</span></h4>
<p>Der Quellcode des Clients ist ähnlich simpel aufgebaut. Dieser versucht zunächst, eine Verbindung zum Server aufzubauen. Ist dies geglückt, wartet er auf eine Antwort vom Server. Schickt der Server dem Client eine Antwort, so wird diese auf die Standardausgabe ausgegeben. Jetzt ist der Client an der Reihe, dem Server eine Zeichenkette zu senden. Geben Sie hierfür »quit« an, beendet sich die Client-Anwendung und nimmt alle Aufräumarbeiten vor. Dass die Aufräumarbeiten (die Funktion <span class="clisting">cleanup()</span>) durchgeführt werden, haben Sie mit der Standard-Funktion <span class="clisting">atexit()</span> sichergestellt, die beim Beenden des Prozesses die Funktion <span class="clisting">cleanup()</span> aufruft (was unter Linux/UNIX unbedeutend ist). Solch ein Cleanup wird generell gern in dieser Form verwendet. Dasselbe Cleanup wird übrigens auch beim Server eingerichtet und durchgeführt, sofern sich dieser beendet.</p>
<p>Ansonsten findet ein reger Kommunikationsaustausch zwischen Server und Client statt. Hier sehen Sie den Quellcode für den Client:</p>
<div class="listing"><pre class="prettyprint">/* client.c */
#include &lt;string.h&gt;
#include "socketprx.h"
#define BUF 1024

int main (int argc, char *argv[]) {
  socket_t sock;
  char *buffer = (char *)malloc (BUF);

  if( argc &lt; 2 ){
     printf("Usage: %s ServerAdresse\n", *argv);
     exit(EXIT_FAILURE);
  }

  sock = create_socket(AF_INET, SOCK_STREAM, 0);
  atexit(cleanup);
  connect_socket(&amp;sock, argv[1], 15000);

  do {
      buffer[0] = '\0';
      TCP_recv (&amp;sock, buffer, BUF-1);
      printf ("Nachricht erhalten: %s\n", buffer);
      printf ("Nachricht zum Versenden: ");
      fgets (buffer, BUF, stdin);
      TCP_send (&amp;sock, buffer, strlen (buffer));
  } while (strcmp (buffer, "quit\n") != 0);
  close_socket (&amp;sock);
  return EXIT_SUCCESS;
}</pre></div><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellenkopf"><span class="cfett">Hinweis</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p class="BStandard">Vergessen Sie beim Übersetzen nicht, die Datei socketlayer.c hinzuzulinken!</p>
</td>
</tr>
</table><br><p>Abbildung 25.6 zeigt das Programm bei der Ausführung.</p>
<div class="bildbox">
<p><a name="IDA4NVQ"></a><a onClick="OpenWin('bilder/25_006.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein25_006.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 25.6    </strong>Die Client-Anwendung unter MS-Windows bei der Ausführung</p>
<div class="bildbox">
<p><a name="IDACOVQ"></a><a onClick="OpenWin('bilder/25_007.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein25_007.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 25.7    </strong>Die Server-Anwendung unter MS-Windows bei der Ausführung</p>
<div class="bildbox">
<p><a name="IDAGOVQ"></a><a onClick="OpenWin('bilder/25_008.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein25_008.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 25.8    </strong>Die Client-Anwendung unter Linux bei der Ausführung</p>
<div class="bildbox">
<p><a name="IDAKOVQ"></a><a onClick="OpenWin('bilder/25_009.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein25_009.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 25.9    </strong>Die Server-Anwendung unter Linux bei der Ausführung</p><a id="mj111a55df67b579f4ca5d1646d87861f6" name="mj111a55df67b579f4ca5d1646d87861f6"></a><a name="t37"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div><a name="t2t38"></a><h3 class="t3"><span class="cfett">25.7.7</span><span class="cfett"> Ein UDP-Beispiel</span>  <a href="#t2t39"><img src="common/down.gif" width="15" height="15" border="0" alt="Zur nächsten Überschrift"></a><a href="#t2t37"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Bei unserem Layer wurden ja auch Funktionen zum Datenaustausch via UDP geschrieben. Außerdem wurde auch einiges zu UDP erwähnt, sodass ich Ihnen hier ein kleines Client/Server-Beispiel nicht vorenthalten will.</p>
<h4 class="t4"><span class="cfett">Der Server</span></h4>
<p>Der Server wartet auf die Verbindung irgendeines Clients, der einen einfachen String als zweites Argument in der Kommandozeile versendet. Der Server gibt diese Zeichen mitsamt der lokalen Server-Uhrzeit auf die Standardausgabe aus und wartet anschließend erneut wieder auf Daten am Port 1234 von irgendeinem Client.</p>
<div class="listing"><pre class="prettyprint">/* udp_server.c */
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include "socketprx.h"

#define LOCAL_SERVER_PORT 1234
#define BUF 255

int main (int argc, char *argv[]) {
  socket_t sock;
  char puffer[BUF];
  time_t time1;
  char loctime[BUF];
  char *ptr;

  /* Socket erzeugen */
  sock = create_socket( AF_INET, SOCK_DGRAM, 0);
  atexit(cleanup);
  bind_socket(&amp;sock, INADDR_ANY, LOCAL_SERVER_PORT);
  printf ("Warte auf Daten am Port (UDP) %u\n",
     LOCAL_SERVER_PORT);
  /* Server-Schleife */
  while (1) {
    memset (puffer, 0, BUF);
    UDP_recv( &amp;sock, puffer, BUF );
    /* Zeitangaben präparieren */
    time(&amp;time1);
    strncpy(loctime, ctime(&amp;time1), BUF);
    ptr = strchr(loctime, '\n' );
    *ptr = '\0';

    /* erhaltene Nachricht ausgeben */
    printf ("%s: Daten erhalten: %s\n",
            loctime, puffer);
  }
  return EXIT_SUCCESS;
}</pre></div>
<h4 class="t4"><span class="cfett">Der Client</span></h4>
<div class="listing"><pre class="prettyprint">/* udp_client.c */
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include "socketprx.h"
#define BUF 1024
#define SERVER_PORT 1234

int main (int argc, char *argv[]) {
  socket_t sock;
  /* Kommandozeile auswerten */
  if (argc &lt; 3) {
    printf ("Usage: %s &lt;server&gt; &lt;string&gt;\n",argv[0]);
    exit (EXIT_FAILURE);
  }

  /* Socket erzeugen */
  sock = create_socket( AF_INET, SOCK_DGRAM, 0);
  atexit(cleanup);
  bind_socket(&amp;sock, INADDR_ANY, 0);
  UDP_send(&amp;sock,argv[2],strlen(argv[2]),argv[1], SERVER_PORT);

  return EXIT_SUCCESS;
}</pre></div>
<p>Abbildung 25.10 zeigt das Programm bei der Ausführung.</p>
<div class="bildbox">
<p><a name="IDALTVQ"></a><a onClick="OpenWin('bilder/25_010.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein25_010.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 25.10    </strong>Der UDP-Server im Einsatz unter Linux</p>
<div class="bildbox">
<p><a name="IDAPTVQ"></a><a onClick="OpenWin('bilder/25_011.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein25_011.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 25.11    </strong>Die (UDP)Client-Anwendung unter Linux</p><a id="mje2ffcc22df9d40b6c9fc2747f25ddd89" name="mje2ffcc22df9d40b6c9fc2747f25ddd89"></a><a name="t38"></a><br><div align="center"><a href="#top"><img src="common/top.gif" border="0" alt="Rheinwerk Computing - Zum Seitenanfang"></a></div><a name="t2t39"></a><h3 class="t3"><span class="cfett">25.7.8</span><span class="cfett"> Mehrere Clients gleichzeitig behandeln</span>  <img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"><a href="#t2t38"><img src="common/top.gif" width="15" height="15" border="0" alt="Zur vorigen Überschrift"></a></h3>
<p>Einen gravierenden Nachteil allerdings hatten alle Server-Beispiele, die Sie bisher geschrieben haben. Alle Server sind nur für eine Client-Anfrage ausgelegt &#8211; sprich, die Server konnten nur einen Client gleichzeitig bearbeiten. Alle anderen Clients wurden in die Warteschlange gesteckt und mussten warten, bis der Server wieder für weitere Verbindungswünsche frei ist. Für Anwendungen wie Webserver, Chat-Programme, Spiele-Server etc. ist dieser Zustand unbrauchbar.</p>
<p>Um diesen Zustand zu verbessern, gibt es mehrere Möglichkeiten, wobei sich hier die Varianten auf den verschiedenen Plattformen erheblich unterscheiden. Sinnvolle und mögliche Varianten wären:</p>
<ul class="gp">
<li><span class="ckursiv">die Verwendung von (Multi-)Threads</span> &#8211; Dabei wird für jeden Client ein neuer Thread gestartet. Der »Nachteil« von Threads ist, dass es auf den verschiedenen Plattformen die verschiedensten Thread-Bibliotheken gibt und somit nur bedingt portabel sind.</li>
</ul>
<ul class="gp">
<li><span class="ckursiv">die Verwendung von Prozessen</span> &#8211; Hierbei wird für jeden Client ein neuer (Server&ndash;)Prozess gestartet &#8211; jeder Client bekommt hierbei praktisch seinen eigenen Server. Voraussetzung hierfür ist allerdings, dass Sie sich mit der Systemprogrammierung der entsprechenden Plattform auskennen. Schließlich müssen die einzelnen Prozesse kontrolliert werden.</li>
</ul><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellenkopf"><span class="cfett">Hinweis</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p class="BStandard">Sofern Sie mehr zu Linux/UNIX tendieren, möchte ich Ihnen mein Buch »Linux-UNIX-Programmierung« ans Herz legen. In ihm  wird das Thema »Netzwerkprogrammierung« weit umfassender &#8211; auch mit den Threads und Prozessen &#8211; behandelt.</p>
</td>
</tr>
</table><br><p>Neben diesen Möglichkeiten gibt es selbstverständlich eine Reihe weiterer Verfahren, um mehrere Clients zu behandeln. Unter MS-Windows beispielsweise könnten Sie hierfür die <span class="clisting">WSA</span>-Routinen <span class="clisting">WSAAsyncSelect()</span> oder <span class="clisting">WSAEventSelect()</span> verwenden. Bei Linux/UNIX hingegen würden sich hierfür auch asynchrone E/A-Routinen nach »POSIX«-Erweiterungen eignen.</p>
<h4 class="t4"><span class="cfett">»select()« &#8211; Eine portablere Alternative</span></h4>
<p>Neben den eben beschriebenen Möglichkeiten, die Sie verwenden können, um mehrere Clients zu bedienen, soll hier auf die Möglichkeit mit der Funktion <span class="clisting">select()</span> etwas genauer eingegangen werden. Diese Funktion ist sowohl auf MS- als auch auf Linux/UNIX-Systemen vorhanden &#8211; und somit ein geeigneter Kandidat für eine portablere Lösung.</p>
<p>Das Problem bei einem Server, wie Sie ihn bisher verwendet haben, ist, dass dieser immer nur auf einen Socket-Deskriptor gewartet hat und auch immer über einen Socket-Deskriptor Daten empfangen bzw. versendet hat. Wurde beim Server beispielsweise <span class="clisting">revc()</span> aufgerufen, blockierte dieser Aufruf den Socket-Deskriptor so lange, bis der Client wirklich Daten an diesen gesendet hat. Natürlich kann man das Blockieren auch dadurch umgehen, dass man den Socket-Deskriptor als nicht-blockierend einrichtet (beispielsweise mit <span class="clisting">fcntl()</span>). Allerdings sollten Sie bedenken, dass hierbei ständig überprüft wird, ob an einem Socket Daten vorliegen &#8211; das heißt, es wird in einer Schleife dauerhaft gepollt &#8211; was die CPU unnötig belastet. Mit der Funktion <span class="clisting">select()</span> können Sie den Socket-Deskriptor so einrichten, dass nur dann CPU-Zeit benötigt wird, wenn auch wirklich Daten an einem Socket-Deskriptor vorliegen.</p><br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellenkopf"><span class="cfett">Hinweis</span>
</td>
</tr>
<tr>
<td class="tabellentext">
<p class="BStandard">Dieser Abschnitt sollte nicht den Eindruck erwecken, die Funktion <span class="clisting">select()</span> sei eine Routine, die sich nur zur Netzwerkprogrammierung eignet. <span class="clisting">select()</span> kann überall dort eingesetzt werden, wo auch Deskriptoren verwendet werden bzw. synchrones Multiplexing verwendet werden soll. Des Weiteren lassen sich mit <span class="clisting">select()</span> auch hervorragend sogenannte Timeouts einrichten.</p>
</td>
</tr>
</table><br><p>Hier sehen Sie die Syntax zur Funktion <span class="clisting">select()</span> unter Linux/UNIX:</p>
<div class="listing"><pre class="prettyprint">// entsprechend nach POSIX 1003.1-2001
#include &lt;sys/select.h&gt;

// entsprechend nach früheren Standards
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int select( int n, fd_set *readfds, fd_set *writefds,
            fd_set *exceptfds, struct timeval *timeout );</pre></div>
<p>Und hier ist die ähnliche Syntax unter MS-Windows:</p>
<div class="listing"><pre class="prettyprint">int select( int n, fd_set FAR * readfds, fd_set FAR * writefds,
            fd_set FAR * exceptfds,
            const struct timeval FAR * timeout );</pre></div>
<p>Mit dem ersten Parameter <span class="clisting">n</span> geben Sie die Größe der folgenden Menge an. Hierfür wird gewöhnlich der Wert des höchsten (Socket-)Deskriptors plus eins angegeben. Sie sollten sich allerdings nicht darauf verlassen, dass hier automatisch eine aufsteigende und lückenlose Reihenfolge für die (Socket-)Deskriptoren vergeben wird. Welche Nummer der nächste (Socket-)Deskriptor verwendet, entscheidet immer noch das System. Daher empfiehlt es sich, jeden gesetzten (Socket-)Deskriptor mit dem zu vergleichen, der rein theoretisch der höchste ist.</p>
<p>Die nächsten drei Parameter sind Zeiger auf die <span class="clisting">fd_set</span>s, die zum Lesen, Schreiben oder auf Ausnahmen getestet werden. Sofern Sie einen der Parameter nicht verwenden wollen, können Sie hierfür <span class="clisting">NULL</span> angeben. Drei getrennte Sets sind nötig, da man ja nicht alle (Socket-)Deskriptoren auf Lesen oder Schreiben testen möchte.</p>
<p>Der am häufigsten verwendete Parameter (wie es auch im anschließenden Beispiel der Fall ist) ist <span class="clisting">readfds</span>. Mit diesem Parameter wird überprüft, ob auf den (Socket-)Deskriptoren Daten zum Lesen vorhanden sind. Das Gegenstück dazu ist der Parameter <span class="clisting">writefds</span>. Hiermit können Sie die Beschreibbarkeit von (Socket&ndash;)Deskriptoren überprüfen &#8211; sprich, ob ein Deskriptor bereit ist, eine Ausgabe anzunehmen (diese Überprüfung wird beispielsweise gerne bei Pipes verwendet). Der dritte <span class="clisting">fd_set</span>-Parameter, <span class="clisting">exceptfds</span>, wird weitaus seltener verwendet. Mit ihm überprüfen Sie, ob bei einem (Socket-)Deskriptor irgendwelche besonderen Zustände (Ausnahmen) vorliegen. Dies wird beispielsweise bei Out-of-band-Daten (<span class="clisting">MSG_OOB</span>) verwendet (siehe Manual-Page zu <span class="clisting">send()</span> und/oder <span class="clisting">recv()</span>).</p>
<p>Nach dem Aufruf von <span class="clisting">select()</span> wird diese Menge in Teilmengen der Filedeskriptoren verteilt, die die Bedingungen erfüllen.</p>
<p>Mit dem letzten Parameter können Sie ein Timeout, eine Zeit im Format von Sekunden (<span class="clisting">tv_sec</span>) und Mikrosekunden (<span class="clisting">tv_usec</span>), einrichten. Diese Zeit wird dann abgewartet, bis eine bestimmte Bedingung eintritt. Sind Sie daran nicht interessiert, können Sie auch hier <span class="clisting">NULL</span> angeben. Es gibt aber auch einen <span class="ckursiv">Nachteil,</span> wenn sich <span class="clisting">select()</span> vorzeitig verabschiedet (vor dem Ablauf der festgelegten Zeit). <span class="clisting">select()</span> gibt keine Auskunft darüber, wie lange denn tatsächlich gewartet wurde. Dazu muss extra eine Funktion wie beispielsweise <span class="clisting">gettimeofday()</span> aufgerufen werden.</p>
<p>Die Funktion gibt die Anzahl der Filedeskriptoren zurück, die Ihre Bedingung erfüllt haben (einfach die Anzahl der (Socket-)Deskriptoren, die bereit sind). Wenn die Zeit abgelaufen ist (Timeout) wird 0 und bei einem Fehler des Funktionsaufrufs <span class="clisting">select()</span>-1 zurückgegeben.</p>
<p>Ein Problem bei <span class="clisting">select()</span> ist, dass es mit Bitfeldern arbeitet &#8211; was somit abhängig vom Betriebssystem ist. Die Bitfeldgröße bei BSD beispielsweise beträgt 256 und unter Linux 1024. Somit können auf BSD nur die ersten 256 und unter Linux 1024 Deskriptoren angesprochen werden. Unter MS-Windows kann dieser Wert sogar nur bis zu 64 Deskriptoren betragen. Wie viele Deskriptoren Sie nun tatsächlich pro Prozess verwenden können, ist mit der symbolischen Konstante <span class="clisting">FD_SETSIZE</span> definiert. Natürlich macht es jetzt wenig Sinn, alle (Socket&ndash;) Deskriptoren zu überwachen. Zum Glück müssen Sie sich eigentlich recht wenig um diese Menge kümmern, da Ihnen der Datentyp <span class="clisting">fd_set</span> die Arbeit zum Speichern der (Socket-)Deskriptoren abnimmt und einige Makros den Zugriff darauf erleichtern. Hier sehen Sie die Makros, um die Mengen zu bearbeiten:</p>
<div class="listing"><pre class="prettyprint">FD_ZERO(fd_set *set);
FD_SET(int element, fd_set *set);
FD_CLR(int element, fd_set *set);
FD_ISSET(int element, fd_set *set);</pre></div>
<p>Die Makros lassen sich recht schnell erklären. <span class="clisting">FD_ZERO()</span> macht aus der Menge <span class="clisting">set</span> eine leere Menge, <span class="clisting">FD_SET()</span> fügt <span class="clisting">element</span> der Menge <span class="clisting">set</span> hinzu, und <span class="clisting">FD_CLR()</span> entfernt <span class="clisting">element</span> aus der Menge <span class="clisting">set</span>. Mit <span class="clisting">FD_ISSET()</span> können Sie überprüfen, ob <span class="clisting">element</span> in der Menge <span class="clisting">set</span> vorkommt (genauer gesagt: gesetzt ist).</p>
<p>Das folgende Beispiel, ein einfacher TCP-Echo-Server, soll Ihnen die Funktion <span class="clisting">select()</span> demonstrieren. Das Beispiel ist dem 1:1-Chat zwischen dem Server und dem Client recht ähnlich, den Sie in diesem Kapitel bereits geschrieben haben. Nur begnügen wir uns beim Server jetzt damit, dass dieser nur die Zeichenketten auf dem Bildschirm ausgibt und dem Client nicht antwortet. Allerdings gibt es den gravierenden Unterschied, dass der Server nun mehrere Clients »gleichzeitig« behandeln kann &#8211; genauer gesagt bis zu <span class="clisting">FD_SETSIZE</span> Clients. Sobald auch hier ein Client die Zeichenfolge »quit« sendet, entfernt der Server den Client (genauer den (Socket-)Deskriptor) aus der Menge.</p>
<p>Im Beispiel wurde aus Übersichtlichkeitsgründen darauf verzichtet, die <span class="clisting">select()</span>-Abhandlung in unseren Layer SOCKETPRX zu implementieren. In der Praxis wäre dies allerdings sehr sinnvoll, da die Verwendung von <span class="clisting">select()</span> doch zu einem der etwas komplizierteren Teile der Programmierung gehört. Dank des Layers SOCKETPRX kann ich <span class="clisting">select()</span> erheblich leichter abhandeln als ohne. Hier folgt der gut dokumentierte Source-Code zum Server, der nun die Abfragen mehrerer Clients auf einmal abarbeiten kann:</p>
<div class="listing"><pre class="prettyprint">/* multi_server.c */
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include "socketprx.h"
#define BUF 1024

int main (void) {
  socket_t sock1, sock2, sock3;
  int i, ready, sock_max, max=-1;
  int client_sock[FD_SETSIZE];
  fd_set gesamt_sock, lese_sock;
  char *buffer = (char*) malloc (BUF);

  sock_max = sock1 = create_socket(AF_INET, SOCK_STREAM, 0);
  atexit(cleanup);
  bind_socket( &amp;sock1, INADDR_ANY, 15000 );
  listen_socket (&amp;sock1);

  for( i=0; i&lt;FD_SETSIZE; i++)
     client_sock[i] = -1;
  FD_ZERO(&amp;gesamt_sock);
  FD_SET(sock1, &amp;gesamt_sock);

  for (;;) {
    /* immer aktualisieren */
    lese_sock = gesamt_sock;
    /* Hier wird auf die Ankunft von Daten oder
     * neuer Verbindungen von Clients gewartet. */
    ready = select( sock_max+1, &amp;lese_sock, NULL, NULL, NULL );
    /* Eine neue Client-Verbindung ...? */
    if( FD_ISSET(sock1, &amp;lese_sock)) {
       accept_socket( &amp;sock1, &amp;sock2 );
       /* freien Platz für (Socket-)Deskriptor
        * in client_sock suchen und vergeben */
       for( i=0; i&lt; FD_SETSIZE; i++)
          if(client_sock[i] &lt; 0) {
             client_sock[i] = sock2;
             break;
          }
       /* mehr als FD_SETSIZE Clients sind nicht möglich */
       if( i == FD_SETSIZE )
          error_exit("Server überlastet - zu viele Clients");
       /* den neuen (Socket-)Deskriptor zur
        * (Gesamt)Menge hinzufügen */
       FD_SET(sock2, &amp;gesamt_sock);
       /* select() benötigt die höchste
        * (Socket-)Deskriptor-Nummer. */
       if( sock2 &gt; sock_max )
          sock_max = sock2;
       /* höchster Index für client_sock
        * für die anschließende Schleife benötigt */
       if( i &gt; max )
          max = i;
       /* ... weitere (Lese-)Deskriptoren bereit? */
       if( --ready &lt;= 0 )
          continue; //Nein ...
    } //if(FD_ISSET ...

    /* Ab hier werden alle Verbindungen von Clients auf
     * die Ankunft von neuen Daten überprüft. */
    for(i=0; i&lt;=max; i++) {
       if((sock3 = client_sock[i]) &lt; 0)
          continue;
       /* (Socket-)Deskriptor gesetzt ... */
       if(FD_ISSET(sock3, &amp;lese_sock)){
          /* ... dann die Daten lesen */
          TCP_recv (&amp;sock3, buffer, BUF-1);
          printf ("Nachricht empfangen: %s\n", buffer);
          /* Wenn quit erhalten wurde ... */
          if (strcmp (buffer, "quit\n") == 0) {
             /* ... hat sich der Client beendet. */
             close_socket (&amp;sock3);        //Socket schließen
             FD_CLR(sock3, &amp;gesamt_sock);  //aus Menge löschen
             client_sock[i] = -1;          //auf -1 setzen
             printf("Ein Client hat sich beendet\n");
          }
          /* Sind noch lesbare Deskriptoren vorhanden ...? */
          if( --ready &lt;= 0 )
             break; //Nein ...
       }
    }
  } // for(;;)
  return EXIT_SUCCESS;
}</pre></div>
<p>Und jetzt folgt noch der Quellcode zur entsprechenden Client-Anwendung:</p>
<div class="listing"><pre class="prettyprint">/* multi_client.c */
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include "socketprx.h"
#define BUF 1024

int main (int argc, char *argv[]) {
  socket_t sock;
  char *buffer = (char *)malloc (BUF);

  if( argc &lt; 2 ){
     printf("Usage: %s ServerAdresse\n", *argv);
     exit(EXIT_FAILURE);
  }

  sock = create_socket(AF_INET, SOCK_STREAM, 0);
  atexit(cleanup);
  connect_socket(&amp;sock, argv[1], 15000);

  do {
      buffer[0] = '\0';
      printf ("Nachricht zum Versenden: ");
      fgets (buffer, BUF, stdin);
      TCP_send (&amp;sock, buffer, strlen (buffer));
  } while (strcmp (buffer, "quit\n") != 0);
  close_socket (&amp;sock);
  return EXIT_SUCCESS;
}</pre></div>
<p>Abbildung 25.12 zeigt das Programm bei der Ausführung.</p>
<div class="bildbox">
<p><a name="IDATCWQ"></a><a onClick="OpenWin('bilder/25_012.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein25_012.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 25.12    </strong>Der Server kann jetzt mehrere Anfragen (Clients) bearbeiten.</p>
<div class="bildbox">
<p><a name="IDAXCWQ"></a><a onClick="OpenWin('bilder/25_013.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein25_013.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 25.13    </strong>Einer von zwei gerade aktiven Clients</p>
<div class="bildbox">
<p><a name="IDA1CWQ"></a><a onClick="OpenWin('bilder/25_014.gif','Abbildung',800,800)"><img border="0" src="bilderklein/klein25_014.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu vergrößern</span></a></p>
</div>
<p class="tabunter"><strong>Abbildung 25.14    </strong>Der andere der beiden aktiven Clients zur selben Zeit</p><br><hr><a name="kommentar"></a><h3>Ihr Kommentar</h3>
                       Wie hat Ihnen das &lt;openbook&gt; gefallen? Wir freuen uns immer über Ihre freundlichen und kritischen Rückmeldungen.
                       <!--<form action="http://www.galileo-press.de/feedback/openbook" method="post" style="text-align: center; margin-top: 10px;"><input type="hidden" name="openbookurl" value="http://openbook.galileocomputing.de/c_von_a_bis_z/025_c_netzwerkprogrammierung_007.htm"><input type="hidden" name="buchtitel" value="C von A bis Z"><input type="hidden" name="Kapitel" value="25.7 Cross-Plattform-Development"><table border="0">
<tr>
<td><label for="name">Name</label><br></td>
<td><input type="text" name="name" id="name" size="40"><br></td>
</tr>
<tr>
<td><label for="email">E-Mail</label><br></td>
<td><input type="text" name="email" id="email" size="40"><br></td>
</tr>
<tr>
<td valign="top"><label for="comment">Ihr Kommentar</label><br></td>
<td><textarea name="comment" id="comment" rows="10" cols="40"></textarea><br></td>
</tr>
<tr>
<td>
</td>
<td><input type="submit" value="Kommentar absenden"></td>
</tr>
</table>
</form>--><a href="https://www.rheinwerk-verlag.de/feedback/produkt/2132/">>> Zum Feedback-Formular</a>
</div></td>
</tr>
</table></td>
</tr>
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center"><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a href="025_c_netzwerkprogrammierung_006.html" class="navnav"> &lt;&lt;   zurück</a></td>
<td width="49%"><div align="center"><a class="navnav" href="#">&lt;top&gt;</a></div></td>
<td align="right" width="25%"><div align="right"><a href="025_c_netzwerkprogrammierung_008.html" class="navnav">vor   &gt;&gt; </a></div></td>
</tr>
</table></td>
</tr>
</table>
</div></td>
<td width="10" valign="top">&nbsp;&nbsp;</td>
<td width="160" valign="top">
<table border="0" cellpadding="0" cellspacing="0" width="160">
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="tbl2" height="20" colspan="2">
&nbsp;<a href="https://www.rheinwerk-verlag.de/?GPP=opc3" class="nav">
<strong>Zum Katalog</strong></a>
</td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2">
<img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td><a href="https://www.rheinwerk-verlag.de/c-von-a-bis-z_2132/?GPP=opc3">
	<img src="common/1411.gif" width="117" height="167" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C von A bis Z" title="Zum Katalog: C von A bis Z">
<br /><br /><strong>&nbsp;C von A bis Z</strong><br /><img src="common/pfeil_rechts5.gif" border="0" alt="">Jetzt&nbsp;bestellen</a><br /><br />
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="tbl2" height="20" colspan="2"><a href="#kommentar" class="nav"><strong>&nbsp;Ihre Meinung?</strong></a>
</td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td>Wie hat Ihnen das &lt;openbook&gt; gefallen?<br /><a href="#kommentar"><img src="common/pfeil_rechts5.gif" border="0" alt="">Ihre Meinung</a>
<br /><br /></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="tbl2" height="20" colspan="2">&nbsp;<a href="https://www.rheinwerk-verlag.de/?GPP=opc3" class="nav"><strong>Buchtipps</strong></a></td>
</tr>
<tr> 
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="https://www.rheinwerk-verlag.de/cc_3536/?GPP=opc3">
<img src="common/2757.gif" width="69" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C/C++" title="Zum Katalog: C/C++"><br /><br /><br /><br /><br /><br /><br />&nbsp;C/C++</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="https://www.rheinwerk-verlag.de/einstieg-in-c_3557/?GPP=opc3">
<img src="common/2793.gif" width="74" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Einstieg in C" title="Zum Katalog: Einstieg in C"><br /><br /><br /><br /><br /><br /><br />&nbsp;Einstieg in C</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="https://www.rheinwerk-verlag.de/schrodinger-programmiert-c_2853/?GPP=opc3">
<img src="common/1756.gif" width="85" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Schrödinger programmiert C++" title="Zum Katalog: Schrödinger programmiert C++"><br /><br /><br /><br /><br /><br /><br />&nbsp;Schrödinger<br />&nbsp;programmiert C++</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="https://www.rheinwerk-verlag.de/c_3278/?GPP=opc3">
<img src="common/2021.gif" width="69" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C++ Handbuch" title="Zum Katalog: C++ Handbuch"><br /><br /><br /><br /><br /><br /><br />&nbsp;C++ Handbuch</a><br /><br /></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
<a href="https://www.rheinwerk-verlag.de/it-handbuch-fur-fachinformatiker_3329/?GPP=opc3">
<img src="common/2234.gif" width="78" height="100" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: IT-Handbuch für Fachinformatiker" title="Zum Katalog: IT-Handbuch für Fachinformatiker"><br /><br /><br /><br /><br /><br /><br />&nbsp;IT-Handbuch für<br />&nbsp;Fachinformatiker</a><br /><br /></td>
</tr>
</table></td>
</tr>
<tr>
<td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
</tr>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="tbl2" height="20" colspan="2"><strong>&nbsp;Shopping</strong></td>
</tr>
<tr>
<td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
<td valign="top">
<table cellspacing="3">
<tr>
<td><b>Versandkostenfrei</b> bestellen in Deutschland und &Ouml;sterreich<br /><a href="https://www.rheinwerk-verlag.de/hilfe/bestellung_6?GPP=opc3"><img src="common/pfeil_rechts5.gif" border="0" alt="Info">Info</a><br /><br /></td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table><br><br><hr width="70%" align="center">
<div align="center">
<p class="standard"><strong>Copyright © Rheinwerk Verlag GmbH 2009</strong><br>
        Für Ihren privaten Gebrauch dürfen Sie die Online-Version natürlich ausdrucken.
        Ansonsten unterliegt das &lt;openbook&gt; denselben Bestimmungen, wie die
        gebundene Ausgabe: Das Werk einschließlich aller seiner Teile ist urheberrechtlich
        geschützt. Alle Rechte vorbehalten einschließlich der Vervielfältigung, Übersetzung,
        Mikroverfilmung sowie Einspeicherung und Verarbeitung in elektronischen Systemen.</p><br><a href="https://www.rheinwerk-verlag.de/">[Rheinwerk Computing]</a><br><br>
      Rheinwerk Verlag GmbH, Rheinwerkallee 4, 53227 Bonn, Tel.: 0228.42150.0, Fax 0228.42150.77, <a href="mailto:service@rheinwerk-verlag.de">service@rheinwerk-verlag.de</a></div><br><br></body>

<!-- Mirrored from openbook.rheinwerk-verlag.de/c_von_a_bis_z/025_c_netzwerkprogrammierung_007.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 23 Jun 2017 19:53:19 GMT -->
</html>
